<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Алгоритмы - Массивы</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
<div class="container">
    <header>
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">DevInterview</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="nav-link" href="../php.html">PHP - вопросы</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../php_tasks.html">PHP - задачи</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../go.html">Go - вопросы</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../go_tasks.html">Go - задачи</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../db.html">Базы данных</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../architecture.html">Архитектура</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="../algorithms.html">Алгоритмы</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <main>
        <h1>Алгоритмы - Массивы</h1>
        <div class="accordion" id="accordionBlock">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q1">
                        Самая длинная непрерывная последовательность
                    </button>
                </h2>
                <div id="q1" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Этот код решает задачу нахождения длины самой длинной непрерывной подпоследовательности
                            одинаковых элементов в массиве.
                        </p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализируем переменную maxLength для хранения максимальной длины.
                            </li>
                            <li>Проходим по массиву, начиная с первого элемента до предпоследнего.</li>
                            <li>Для каждого элемента:<br/>
                                <ul>
                                    <li>Устанавливаем левый указатель (left) на текущий элемент.</li>
                                    <li>Устанавливаем правый указатель (right) на следующий элемент.
                                    </li>
                                    <li>Двигаем правый указатель вправо, пока встречаются элементы,
                                        равные текущему.
                                    </li>
                                    <li>Вычисляем длину найденной подпоследовательности (right -
                                        left).
                                    </li>
                                    <li>Обновляем maxLength, если найденная длина больше.</li>
                                    <li>Перемещаем индекс i на конец найденной подпоследовательности
                                        минус 1.
                                    </li>
                                </ul>
                            </li>
                            <li>Возвращаем maxLength.</li>
                        </ol>
                        <p>
                            Временная сложность: O(n), где n - длина массива. Несмотря на вложенный
                            цикл, каждый элемент массива просматривается не более двух раз: один раз как
                            начало последовательности и один раз как её продолжение.</p>
                        <p>Пространственная сложность: O(1), так как используется только фиксированное
                            количество дополнительных переменных, независимо от размера входного
                            массива.
                        </p>
                        <pre><code class="go">func findMaxLength(arr []int) int {
	var maxLength int
	for i := 0; i < len(arr)-1; i++ {
		left, right := i, i+1
		for right < len(arr) && arr[left] == arr[right] {
			right++
		}
		maxLength = max(maxLength, right-left)
		i = right - 1
	}
	return maxLength
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q2">
                        Пересечение двух массивов
                    </button>
                </h2>
                <div id="q2" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>intersect</code>, которая находит пересечение двух
                            целочисленных массивов <code>nums1</code> и <code>nums2</code>. Пересечение включает все
                            элементы, которые присутствуют в обоих массивах, с учетом их количества.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Создание хеш-таблицы (map) для подсчета элементов первого массива:
                                <ul>
                                    <li>Проходим по <code>nums1</code> и увеличиваем счетчик для каждого элемента в map.
                                    </li>
                                </ul>
                            </li>
                            <li>Поиск пересечения:
                                <ul>
                                    <li>Проходим по <code>nums2</code>.</li>
                                    <li>Если элемент присутствует в map и его счетчик больше 0:
                                        <ul>
                                            <li>Добавляем элемент в результат.</li>
                                            <li>Уменьшаем счетчик элемента в map.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Возвращаем результирующий массив.</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n + m)
                                <ul>
                                    <li>n - длина nums1</li>
                                    <li>m - длина nums2</li>
                                    <li>Требуется один проход по каждому массиву</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(min(n, m))
                                <ul>
                                    <li>Для хранения map и результирующего массива</li>
                                    <li>В худшем случае размер равен длине меньшего из двух массивов</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func intersect(nums1 []int, nums2 []int) []int {
	// Создаем map для подсчета элементов в nums1
	count := make(map[int]int)
	for _, num := range nums1 {
		count[num]++
	}

	// Создаем слайс для результата
	result := []int{}

	// Проходим по nums2 и проверяем наличие элементов в map
	for _, num := range nums2 {
		if count[num] > 0 {
			result = append(result, num)
			count[num]--
		}
	}

	return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q3">
                        Слияние двух отсортированных массивов
                    </button>
                </h2>
                <div id="q3" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>merge</code>, которая объединяет два отсортированных массива
                            <code>nums1</code> и <code>nums2</code> в один отсортированный массив. Результат сохраняется
                            в массиве <code>nums1</code>, который изначально имеет достаточно места для хранения всех
                            элементов.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация указателей:
                                <ul>
                                    <li><code>p1</code>: указывает на последний элемент в <code>nums1</code></li>
                                    <li><code>p2</code>: указывает на последний элемент в <code>nums2</code></li>
                                    <li><code>p</code>: указывает на последнюю позицию в объединенном массиве</li>
                                </ul>
                            </li>
                            <li>Итерация с конца массивов:
                                <ul>
                                    <li>Сравниваем элементы <code>nums1[p1]</code> и <code>nums2[p2]</code></li>
                                    <li>Больший элемент помещаем в позицию <code>p</code> массива <code>nums1</code>
                                    </li>
                                    <li>Сдвигаем соответствующий указатель и <code>p</code></li>
                                </ul>
                            </li>
                            <li>Продолжаем, пока не обработаем все элементы из <code>nums2</code></li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(m+n)
                                <ul>
                                    <li>m - количество элементов в nums1</li>
                                    <li>n - количество элементов в nums2</li>
                                    <li>Алгоритм проходит по всем элементам обоих массивов один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Алгоритм работает in-place, не используя дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int) {
	// Указатели на последние элементы массивов
	p1 := m - 1    // для nums1
	p2 := n - 1    // для nums2
	p := m + n - 1 // для объединенного массива

	// Идем с конца массивов, заполняя nums1 с конца
	for p2 >= 0 {
		if p1 >= 0 && nums1[p1] > nums2[p2] {
			nums1[p] = nums1[p1]
			p1--
		} else {
			nums1[p] = nums2[p2]
			p2--
		}
		p--
	}
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q4">
                        Поиск пропущенного числа
                    </button>
                </h2>
                <div id="q4" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>missingNumber</code>, которая находит пропущенное число в
                            последовательности от 0 до n, где n - длина входного массива <code>nums</code>.
                            Предполагается, что в массиве <code>nums</code> содержатся все числа от 0 до n, кроме
                            одного.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>sum</code>: сумма всех чисел от 0 до n (включительно)</li>
                                    <li><code>res</code>: сумма всех чисел в массиве <code>nums</code></li>
                                </ul>
                            </li>
                            <li>Итерация по массиву:
                                <ul>
                                    <li>Добавляем i к <code>sum</code> (учитывая числа от 0 до n-1)</li>
                                    <li>Добавляем <code>nums[i]</code> к <code>res</code></li>
                                </ul>
                            </li>
                            <li>Вычисление пропущенного числа:
                                <ul>
                                    <li>Возвращаем разницу между <code>sum</code> и <code>res</code></li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входного массива</li>
                                    <li>Алгоритм проходит по массиву один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func missingNumber(nums []int) int {
	sum := len(nums)
	res := 0
	for i := 0; i < len(nums); i++ {
		sum += i
		res += nums[i]
	}

	return sum - res
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q5">
                        Перемещение нулей в конец массива
                    </button>
                </h2>
                <div id="q5" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>moveZeroes</code>, которая перемещает все нули в конец
                            массива <code>nums</code>, сохраняя относительный порядок ненулевых элементов.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация указателя <code>nonZeroIndex</code>:
                                <ul>
                                    <li>Указывает на позицию, куда нужно поместить следующий ненулевой элемент</li>
                                </ul>
                            </li>
                            <li>Первый проход по массиву:
                                <ul>
                                    <li>Если элемент не равен нулю, перемещаем его на позицию <code>nonZeroIndex</code>
                                    </li>
                                    <li>Увеличиваем <code>nonZeroIndex</code></li>
                                </ul>
                            </li>
                            <li>Второй проход по оставшейся части массива:
                                <ul>
                                    <li>Заполняем все позиции от <code>nonZeroIndex</code> до конца массива нулями</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входного массива</li>
                                    <li>Алгоритм проходит по массиву дважды: один раз для перемещения ненулевых
                                        элементов и второй раз для заполнения нулями
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Алгоритм работает in-place, не используя дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func moveZeroes(nums []int) {
	nonZeroIndex := 0

	// Перемещаем все ненулевые элементы в начало массива
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			nums[nonZeroIndex] = nums[i]
			nonZeroIndex++
		}
	}

	// Заполняем оставшуюся часть массива нулями
	for i := nonZeroIndex; i < len(nums); i++ {
		nums[i] = 0
	}
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q6">
                        Сортировка квадратов элементов отсортированного массива
                    </button>
                </h2>
                <div id="q6" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>sortedSquares</code> принимает отсортированный массив целых чисел (возможно,
                            содержащий отрицательные числа) и возвращает новый массив, содержащий квадраты этих чисел в
                            отсортированном порядке.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация:
                                <ul>
                                    <li>Создаем результирующий массив той же длины, что и входной</li>
                                    <li>Устанавливаем два указателя: <code>left</code> в начало и <code>right</code> в
                                        конец входного массива
                                    </li>
                                </ul>
                            </li>
                            <li>Итерация с конца результирующего массива:
                                <ul>
                                    <li>Сравниваем абсолютные значения чисел на левом и правом указателях</li>
                                    <li>Больший квадрат помещаем в текущую позицию результата</li>
                                    <li>Сдвигаем соответствующий указатель</li>
                                </ul>
                            </li>
                            <li>Повторяем, пока не заполним весь результирующий массив</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входного массива</li>
                                    <li>Алгоритм проходит по всем элементам ровно один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>Создается новый массив для хранения результата, длина которого равна длине
                                        входного массива
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func sortedSquares(nums []int) []int {
	n := len(nums)
	result := make([]int, n)
	left, right := 0, n-1

	for i := n - 1; i >= 0; i-- {
		if abs(nums[left]) > abs(nums[right]) {
			result[i] = nums[left] * nums[left]
			left++
		} else {
			result[i] = nums[right] * nums[right]
			right--
		}
	}

	return result
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q7">
                        Суммирование диапазонов в отсортированном массиве ["0->2", "4->5", "7"]
                    </button>
                </h2>
                <div id="q7" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>summaryRanges</code> принимает отсортированный массив целых чисел и возвращает
                            список строк, представляющих диапазоны последовательных чисел в этом массиве.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка на пустой массив:
                                <ul>
                                    <li>Если массив пуст, возвращаем пустой список строк</li>
                                </ul>
                            </li>
                            <li>Инициализация:
                                <ul>
                                    <li>Создаем пустой список строк для результата</li>
                                    <li>Инициализируем пустую строку <code>current</code> для хранения начала текущего
                                        диапазона
                                    </li>
                                </ul>
                            </li>
                            <li>Итерация по массиву:
                                <ul>
                                    <li>Для каждого числа проверяем три случая:
                                        <ol>
                                            <li>Не последний элемент и нет текущего диапазона</li>
                                            <li>Не последний элемент и есть текущий диапазон</li>
                                            <li>Последний элемент массива</li>
                                        </ol>
                                    </li>
                                    <li>В зависимости от случая, либо начинаем новый диапазон, либо завершаем текущий,
                                        либо добавляем одиночное число
                                    </li>
                                </ul>
                            </li>
                            <li>Формирование результата:
                                <ul>
                                    <li>Добавляем сформированные диапазоны или одиночные числа в результирующий список
                                    </li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входного массива</li>
                                    <li>Алгоритм проходит по всем элементам массива ровно один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае (когда каждое число образует отдельный диапазон) результирующий
                                        список будет содержать n элементов
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func summaryRanges(nums []int) []string {
	if len(nums) == 0 {
		return []string{}
	}

	var res []string
	current := ""

	for i, num := range nums {
		switch {
		case i < len(nums)-1 && current == "":
			if num+1 == nums[i+1] {
				current = strconv.Itoa(num)
			} else {
				res = append(res, strconv.Itoa(num))
			}
		case i < len(nums)-1 && current != "":
			if num+1 != nums[i+1] {
				res = append(res, current+"->"+strconv.Itoa(num))
				current = ""
			}
		case i == len(nums)-1:
			if current != "" {
				res = append(res, current+"->"+strconv.Itoa(num))
			} else {
				res = append(res, strconv.Itoa(num))
			}
		}
	}

	return res
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q8">
                        "Two Sum" (Два числа) [Найти индекс чисел в массиве которые дадут target сумму]
                    </button>
                </h2>
                <div id="q8" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>twoSum</code> находит два числа в массиве, сумма которых равна заданному
                            целевому значению (target). Возвращает индексы этих двух чисел.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация:
                                <ul>
                                    <li>Создаем пустую хеш-таблицу (map) для хранения чисел и их индексов</li>
                                </ul>
                            </li>
                            <li>Итерация по массиву:
                                <ul>
                                    <li>Для каждого числа вычисляем его дополнение (complement) до целевого значения
                                    </li>
                                    <li>Проверяем, есть ли дополнение в хеш-таблице</li>
                                    <li>Если есть, возвращаем индексы текущего числа и его дополнения</li>
                                    <li>Если нет, добавляем текущее число и его индекс в хеш-таблицу</li>
                                </ul>
                            </li>
                            <li>Если решение не найдено:
                                <ul>
                                    <li>Возвращаем nil</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - количество элементов в массиве</li>
                                    <li>Алгоритм проходит по массиву только один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае хеш-таблица может содержать все n элементов массива</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func twoSum(nums []int, target int) []int {
	m := make(map[int]int)
	for i, num := range nums {
		complement := target - num
		if j, ok := m[complement]; ok {
			return []int{j, i}
		}
		m[num] = i
	}

	return nil
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q8-2">
                        "Two Sum" (Два числа) [Найти индекс чисел в массиве которые дадут target сумму]
                        (без использования памяти)
                    </button>
                </h2>
                <div id="q8-2" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Дан отсортированный по возрастанию массив целых чисел 'a' и целевое значение 'target'.
                            Необходимо найти два индекса 0 ≤ l < r < n, такие что a[l] + a[r] == target. Если такая пара
                            существует, нужно вернуть эти индексы. В противном случае вернуть признак отсутствия
                            решения.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализировать два указателя: left (в начале массива) и right (в конце массива).</li>
                            <li>Пока left < right:
                                <ul>
                                    <li>Вычислить сумму элементов a[left] и a[right].</li>
                                    <li>Если сумма равна target, вернуть индексы left и right.</li>
                                    <li>Если сумма меньше target, увеличить left.</li>
                                    <li>Если сумма больше target, уменьшить right.</li>
                                </ul>
                            </li>
                            <li>Если цикл завершился без нахождения решения, вернуть признак отсутствия решения.</li>
                        </ol>
                        <ul>
                            <li>Временная сложность: O(n), где n - длина массива.</li>
                            <li>Пространственная сложность: O(1), используется константное дополнительное
                                пространство.
                            </li>
                        </ul>
                        <pre><code class="go">func twoSum(nums []int, target int) (int, int) {
    left, right := 0, len(nums)-1

    for left < right {
        sum := nums[left] + nums[right]
        if sum == target {
            return left, right
        } else if sum < target {
            left++
        } else {
            right--
        }
    }

    // Если пара не найдена, возвращаем недопустимые индексы
    return -1, -1
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q9">
                        Вычисление выражения в обратной польской записи
                    </button>
                </h2>
                <div id="q9" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>evalRPN</code> вычисляет результат арифметического выражения, записанного в
                            обратной польской нотации (RPN). В этой нотации операнды располагаются перед операторами.
                        </p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация:
                                <ul>
                                    <li>Создаем пустой стек для хранения чисел</li>
                                </ul>
                            </li>
                            <li>Итерация по токенам:
                                <ul>
                                    <li>Если токен - число, добавляем его в стек</li>
                                    <li>Если токен - оператор:
                                        <ul>
                                            <li>Извлекаем два последних числа из стека</li>
                                            <li>Выполняем соответствующую операцию</li>
                                            <li>Результат помещаем обратно в стек</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Завершение:
                                <ul>
                                    <li>Возвращаем единственное число, оставшееся в стеке (результат вычисления)</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - количество токенов в входном массиве</li>
                                    <li>Алгоритм проходит по каждому токену ровно один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае стек может содержать все числа из входного массива</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func evalRPN(tokens []string) int {
	stack := make([]int, 0)
	for _, token := range tokens {
		if num, err := strconv.Atoi(token); err == nil {
			stack = append(stack, num)
			continue
		}
		a, b := stack[len(stack)-2], stack[len(stack)-1]
		stack = stack[:len(stack)-2]

		switch token {
		case "+":
			stack = append(stack, a+b)
		case "-":
			stack = append(stack, a-b)
		case "*":
			stack = append(stack, a*b)
		case "/":
			stack = append(stack, a/b)
		}
	}

	return stack[0]
}
</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q10">
                        Поиск первой и последней позиции элемента в отсортированном массиве
                    </button>
                </h2>
                <div id="q10" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>searchRange</code> находит начальную и конечную позиции заданного целевого
                            значения в отсортированном массиве. Если целевое значение не найдено, возвращается [-1, -1].
                        </p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка на пустой массив:
                                <ul>
                                    <li>Если массив пуст, возвращаем [-1, -1]</li>
                                </ul>
                            </li>
                            <li>Бинарный поиск:
                                <ul>
                                    <li>Инициализируем указатели left и right на начало и конец массива</li>
                                    <li>Выполняем бинарный поиск, пока left ≤ right</li>
                                    <li>Если найдено целевое значение:
                                        <ul>
                                            <li>Расширяем диапазон влево и вправо, пока находим целевое значение</li>
                                            <li>Возвращаем найденный диапазон</li>
                                        </ul>
                                    </li>
                                    <li>Если значение в середине меньше цели, сдвигаем left</li>
                                    <li>Если значение в середине больше цели, сдвигаем right</li>
                                </ul>
                            </li>
                            <li>Если целевое значение не найдено, возвращаем [-1, -1]</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong>
                                <ul>
                                    <li>В лучшем и среднем случае: O(log n) - благодаря бинарному поиску</li>
                                    <li>В худшем случае: O(n) - когда все элементы равны целевому значению</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func searchRange(nums []int, target int) []int {
	if len(nums) == 0 {
		return []int{-1, -1}
	}

	left, right := 0, len(nums)-1

	for left <= right {
		mid := left + (right-left)/2

		if nums[mid] == target {
			// считаем элементы слева и справа
			l, r := mid, mid
			for {
				if l >= 0 && nums[l] == target {
					l--
				}
				if r < len(nums) && nums[r] == target {
					r++
				}

				if (l < 0 || nums[l] != target) && (r == len(nums) || nums[r] != target) {
					return []int{l + 1, r - 1}
				}
			}
		}

		if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}

	return []int{-1, -1}
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q11">
                        Поиск K ближайших элементов
                    </button>
                </h2>
                <div id="q11" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>findClosestElements</code> находит K ближайших элементов к заданному числу X в
                            отсортированном массиве.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка граничных условий:
                                <ul>
                                    <li>Если длина массива меньше K или массив пуст, возвращаем весь массив</li>
                                    <li>Если X меньше или равно первому элементу, возвращаем первые K элементов</li>
                                    <li>Если X больше или равно последнему элементу, возвращаем последние K элементов
                                    </li>
                                </ul>
                            </li>
                            <li>Бинарный поиск:
                                <ul>
                                    <li>Инициализируем левую границу поиска как 0, правую как len(arr) - K</li>
                                    <li>Выполняем бинарный поиск, пока left < right:
                                        <ul>
                                            <li>Находим середину диапазона</li>
                                            <li>Сравниваем расстояния от X до элементов arr[mid] и arr[mid+K]</li>
                                            <li>Сдвигаем границы поиска в зависимости от результата сравнения</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Возвращаем подмассив длины K, начиная с найденной позиции</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(log(n-k) + k)
                                <ul>
                                    <li>log(n-k) - для бинарного поиска</li>
                                    <li>k - для формирования результирующего массива</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(k)
                                <ul>
                                    <li>Для хранения результирующего массива</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func findClosestElements(arr []int, k int, x int) []int {
	if len(arr) < k || len(arr) == 0 {
		return arr
	}

	left, right := 0, len(arr)-k // ставим окно поиска

	// Проверка граничных случаев
	if x <= arr[0] { // 0 элемент больше x то берём первые k элементов
		return arr[:k]
	}
	if x >= arr[len(arr)-1] { // если последний элемент больше x, то берём последние k элементов
		return arr[len(arr)-k:]
	}

	// Бинарный поиск
	for left < right {
		mid := left + (right-left)/2
		if x-arr[mid] > arr[mid+k]-x { // если x больше среднего, двигаем в правую часть
			left = mid + 1
		} else {
			right = mid
		}
	}
	return arr[left : left+k]
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q12">
                        Группировка анаграмм
                    </button>
                </h2>
                <div id="q12" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>groupAnagrams</code> группирует анаграммы из заданного списка строк. Анаграммы
                            - это слова, состоящие из одних и тех же букв, но в разном порядке.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация:
                                <ul>
                                    <li>Создаем пустую карту (map) для хранения групп анаграмм</li>
                                </ul>
                            </li>
                            <li>Обработка каждой строки:
                                <ul>
                                    <li>Преобразуем строку в слайс рун</li>
                                    <li>Сортируем символы строки</li>
                                    <li>Используем отсортированную строку как ключ в карте</li>
                                    <li>Добавляем исходную строку в соответствующую группу в карте</li>
                                </ul>
                            </li>
                            <li>Формирование результата:
                                <ul>
                                    <li>Преобразуем карту в слайс слайсов строк</li>
                                </ul>
                            </li>
                            <li>Возвращаем результат</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n * k * log(k))
                                <ul>
                                    <li>n - количество строк в исходном слайсе</li>
                                    <li>k - максимальная длина строки</li>
                                    <li>Сортировка каждой строки занимает O(k * log(k))</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n * k)
                                <ul>
                                    <li>Для хранения всех строк в карте и результирующем слайсе</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func groupAnagrams(strs []string) [][]string {
	groups := make(map[string][]string)

	for _, str := range strs {
		// Сортируем символы строки для получения ключа
		chars := []rune(str)
		slices.Sort(chars)
		key := string(chars)

		// Добавляем строку в соответствующую группу
		groups[key] = append(groups[key], str)
	}

	// Преобразуем map в slice
	result := make([][]string, 0, len(groups))
	for _, group := range groups {
		result = append(result, group)
	}

	return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q13">
                        Поиск самого длинного подмассива единиц после удаления одного элемента
                    </button>
                </h2>
                <div id="q13" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>longestSubarray</code> находит длину самого длинного подмассива, состоящего
                            только из единиц, после удаления одного элемента из исходного массива.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>left</code> - левая граница окна</li>
                                    <li><code>zeros</code> - количество нулей в текущем окне</li>
                                    <li><code>maxLen</code> - максимальная длина найденного подмассива</li>
                                </ul>
                            </li>
                            <li>Проход по массиву с использованием техники "скользящего окна":
                                <ul>
                                    <li>Расширяем окно вправо</li>
                                    <li>Если встречаем ноль, увеличиваем счетчик нулей</li>
                                    <li>Если в окне больше одного нуля, сужаем окно слева</li>
                                    <li>Обновляем максимальную длину подмассива</li>
                                </ul>
                            </li>
                            <li>Обработка особого случая:
                                <ul>
                                    <li>Если максимальная длина равна длине исходного массива, вычитаем 1</li>
                                </ul>
                            </li>
                            <li>Возвращаем результат</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - количество элементов в массиве</li>
                                    <li>Каждый элемент обрабатывается не более двух раз (при расширении и сужении
                                        окна)
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func longestSubarray(nums []int) int {
	left, zeros, maxLen := 0, 0, 0

	for right := 0; right < len(nums); right++ {
		if nums[right] == 0 {
			zeros++
		}

		// Сужаем окно, если в нем больше одного нуля
		for zeros > 1 {
			if nums[left] == 0 {
				zeros--
			}
			left++
		}

		// Обновляем максимальную длину
		// Вычитаем 1, так как нужно удалить один элемент
		maxLen = max(maxLen, right-left)
	}

	// Если maxLen равен длине массива, возвращаем maxLen-1,
	// иначе возвращаем maxLen
	if maxLen == len(nums) {
		return maxLen - 1
	}
	return maxLen
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q14">
                        Поиск максимального количества последовательных единиц (с заменой k нулей)
                    </button>
                </h2>
                <div id="q14" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>longestOnes</code> находит длину самого длинного подмассива, состоящего только
                            из единиц, после замены не более k нулей на единицы.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>left</code> - левая граница окна</li>
                                    <li><code>maxOnes</code> - максимальная длина найденного подмассива</li>
                                </ul>
                            </li>
                            <li>Проход по массиву с использованием техники "скользящего окна":
                                <ul>
                                    <li>Расширяем окно вправо</li>
                                    <li>Если встречаем ноль, уменьшаем k</li>
                                    <li>Если k становится отрицательным, сдвигаем левую границу окна</li>
                                    <li>Обновляем максимальную длину подмассива</li>
                                </ul>
                            </li>
                            <li>Возвращаем результат</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - количество элементов в массиве</li>
                                    <li>Каждый элемент обрабатывается не более двух раз (при расширении и сужении
                                        окна)
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>


                        <pre><code class="go">func longestOnes(nums []int, k int) int {
	left, maxOnes := 0, 0
	for right := 0; right < len(nums); right++ {
		if nums[right] == 0 {
			k--
		}
		if k < 0 {
			if nums[left] == 0 {
				k++
			}
			left++
		}
		maxOnes = max(maxOnes, right-left+1)
	}
	return maxOnes
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q15">
                        Максимизация расстояния до ближайшего человека
                    </button>
                </h2>
                <div id="q15" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>maxDistToClosest</code> находит максимальное расстояние, на котором можно сесть
                            от ближайшего человека в ряду сидений, представленном массивом <code>seats</code>, где 1
                            означает занятое место, а 0 - свободное.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>n</code> - длина массива seats</li>
                                    <li><code>left</code> - индекс последнего занятого места слева (изначально -1)</li>
                                    <li><code>maxDist</code> - максимальное найденное расстояние</li>
                                </ul>
                            </li>
                            <li>Проход по массиву seats:
                                <ul>
                                    <li>Если встречаем занятое место (1):
                                        <ul>
                                            <li>Если это первое занятое место, проверяем расстояние от начала ряда</li>
                                            <li>Иначе вычисляем расстояние между текущим и предыдущим занятым местом
                                            </li>
                                            <li>Обновляем <code>maxDist</code>, если найдено большее расстояние</li>
                                            <li>Обновляем <code>left</code></li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>После прохода проверяем расстояние от последнего занятого места до конца ряда</li>
                            <li>Возвращаем максимальное найденное расстояние</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - длина массива seats</li>
                                    <li>Алгоритм проходит по массиву ровно один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительных переменных</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func maxDistToClosest(seats []int) int {
	n := len(seats)
	left := -1 // индекс последнего занятого места слева
	maxDist := 0

	for i := 0; i < n; i++ {
		if seats[i] == 1 {
			// Если это первое занятое место, проверяем расстояние от начала
			if left == -1 {
				maxDist = i
			} else {
				// Иначе проверяем расстояние между двумя занятыми местами
				maxDist = max(maxDist, (i-left)/2)
			}
			left = i
		}
	}

	// Проверяем расстояние от последнего занятого места до конца
	maxDist = max(maxDist, n-1-left)

	return maxDist
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q16">
                        Поиск медианы двух отсортированных массивов
                    </button>
                </h2>
                <div id="q16" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>findMedianSortedArrays</code> находит медиану двух отсортированных массивов
                            <code>nums1</code> и <code>nums2</code>.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Обработка краевых случаев:
                                <ul>
                                    <li>Если один из массивов пустой, возвращается медиана другого массива</li>
                                </ul>
                            </li>
                            <li>Оптимизация:
                                <ul>
                                    <li>Обеспечение того, что <code>nums1</code> - более короткий массив</li>
                                </ul>
                            </li>
                            <li>Бинарный поиск по более короткому массиву:
                                <ul>
                                    <li>Поиск правильной точки разделения в обоих массивах</li>
                                    <li>Сравнение элементов на границах разделения</li>
                                    <li>Корректировка точки разделения в зависимости от сравнения</li>
                                </ul>
                            </li>
                            <li>Вычисление медианы:
                                <ul>
                                    <li>Для четного общего количества элементов - среднее двух средних элементов</li>
                                    <li>Для нечетного - максимальный из двух "левых" элементов</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(log(min(m, n)))
                                <ul>
                                    <li>m и n - длины массивов nums1 и nums2 соответственно</li>
                                    <li>Бинарный поиск выполняется по более короткому массиву</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	// Обработка случая, когда один из массивов пустой
	if len(nums1) == 0 {
		return medianOfArray(nums2)
	}
	if len(nums2) == 0 {
		return medianOfArray(nums1)
	}

	// Мы всегда работаем с меньшим массивом как с nums1 для оптимизации.
	if len(nums1) > len(nums2) {
		nums1, nums2 = nums2, nums1
	}
	l1, l2 := len(nums1), len(nums2)

	// бинарный поиск
	left, right := 0, l1
	for left <= right {
		cur1 := (left + right) / 2
		cur2 := (l1+l2+1)/2 - cur1
		/* Вычисляем соответствующую точку разделения для второго массива: cur2 = (l1 + l2 + 1) / 2 - cur1
		Это обеспечивает, что левая часть обоих массивов всегда содержит (l1 + l2 + 1) / 2 элементов */
		first1 := getVal(nums1, cur1, math.MaxInt)
		last1 := getVal(nums1, cur1-1, math.MinInt)
		first2 := getVal(nums2, cur2, math.MaxInt)
		last2 := getVal(nums2, cur2-1, math.MinInt)

		switch {
		case last1 <= first2 && last2 <= first1:
			// чётное кол-во или нет
			if (l1+l2)%2 == 0 {
				return (float64(max(last1, last2)) + float64(min(first1, first2))) / 2.0
			}
			return float64(max(last1, last2))
		case last1 > first2:
			right = cur1 - 1
		default:
			left = cur1 + 1
		}
	}

	return 0.0
}

/*
*
Функция getVal используется для безопасного получения этих значений,
возвращая минимальное или максимальное целое число, если индекс выходит за границы массива.
*/
func getVal(nums []int, index int, defaultVal int) int {
	if index < 0 || index >= len(nums) {
		return defaultVal
	}
	return nums[index]
}

func medianOfArray(nums []int) float64 {
	n := len(nums)
	if n%2 == 0 {
		return float64(nums[n/2-1]+nums[n/2]) / 2.0
	}
	return float64(nums[n/2])
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q17">
                        Объединение пересекающихся интервалов
                    </button>
                </h2>
                <div id="q17" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>findNonOverlappingIntervals</code> принимает массив интервалов и возвращает
                            новый массив, где все пересекающиеся интервалы объединены.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка на пустой входной массив</li>
                            <li>Сортировка интервалов по начальной точке (при равенстве - по конечной точке)</li>
                            <li>Итерация по отсортированным интервалам:
                                <ul>
                                    <li>Если текущий интервал пересекается с предыдущим, объединяем их</li>
                                    <li>Если не пересекается, добавляем предыдущий интервал в результат и начинаем
                                        новый
                                    </li>
                                </ul>
                            </li>
                            <li>Добавление последнего обработанного интервала в результат</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n log n)
                                <ul>
                                    <li>Сортировка интервалов занимает O(n log n)</li>
                                    <li>Последующая итерация по интервалам занимает O(n)</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае, когда нет пересечений, результирующий массив будет такого же
                                        размера, как входной
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func findNonOverlappingIntervals(intervals [][]int) [][]int {
	if len(intervals) == 0 {
		return [][]int{}
	}

	slices.SortFunc(intervals, func(i, j []int) int { // log n
		switch {
		case i[0] == j[0] && i[1] == j[1]:
			return 0
		case i[0] < j[0] || (i[0] == j[0] && i[1] < j[1]):
			return -1
		default:
			return 1
		}
	})

	var resultIntervals [][]int
	currentInterval := intervals[0]
	for _, interval := range intervals[1:] {
		switch {
		case interval[0] <= currentInterval[1]: // [1, 3] in [2, 6]
			currentInterval[1] = max(currentInterval[1], interval[1])
		case interval[0] > currentInterval[1]: // [1, 3] in [5, 7]
			resultIntervals = append(resultIntervals, currentInterval)
			currentInterval = interval
		}
	}
	resultIntervals = append(resultIntervals, currentInterval)

	return resultIntervals
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q18">
                        Слияние K отсортированных массивов
                    </button>
                </h2>
                <div id="q18" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>MergeKSortedArrays</code> объединяет K отсортированных массивов в один
                            отсортированный массив.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация результирующего массива и массива указателей для каждого входного
                                массива
                            </li>
                            <li>Итеративный процесс:
                                <ul>
                                    <li>Поиск минимального элемента среди текущих элементов всех массивов</li>
                                    <li>Добавление найденного минимального элемента в результат</li>
                                    <li>Продвижение указателя для массива, из которого был взят минимальный элемент</li>
                                </ul>
                            </li>
                            <li>Повторение процесса, пока все элементы не будут обработаны</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(N * k)
                                <ul>
                                    <li>N - общее количество элементов во всех массивах</li>
                                    <li>k - количество массивов</li>
                                    <li>На каждой итерации происходит поиск минимума среди k элементов</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(N + k)
                                <ul>
                                    <li>O(N) для результирующего массива</li>
                                    <li>O(k) для массива указателей</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func MergeKSortedArrays(arrays [][]int) []int {
	result := make([]int, 0)
	points := make([]int, len(arrays))

	for {
		minVal := 101
		minIdx := -1

		// Ищем минимальный индекс
		for i, arr := range arrays {
			if points[i] < len(arr) &&
				(minIdx < 0 || arr[points[i]] < minVal) {
				minVal = arr[points[i]]
				minIdx = i
			}
		}

		// Если не нашли минимальный элемент, значит все массивы обработаны
		if minIdx == -1 {
			break
		}

		// Добавляем минимальный элемент в результат и двигаем указатель
		result = append(result, minVal)
		points[minIdx]++
	}

	return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q19">
                        Произведение элементов массива, кроме самого себя
                    </button>
                </h2>
                <div id="q19" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>productExceptSelf</code> вычисляет для каждого элемента массива произведение
                            всех остальных элементов, не используя операцию деления.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация результирующего массива <code>answer</code></li>
                            <li>Вычисление префиксных произведений:
                                <ul>
                                    <li>Проход слева направо</li>
                                    <li>Каждый элемент <code>answer[i]</code> содержит произведение всех элементов слева
                                        от <code>nums[i]</code></li>
                                </ul>
                            </li>
                            <li>Вычисление суффиксных произведений и формирование окончательного результата:
                                <ul>
                                    <li>Проход справа налево</li>
                                    <li>Умножение каждого элемента <code>answer[i]</code> на суффиксное произведение
                                    </li>
                                    <li>Обновление суффиксного произведения</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Два прохода по массиву: один слева направо, другой справа налево</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Не считая выходной массив, используется только одна дополнительная переменная
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func productExceptSelf(nums []int) []int {
	n := len(nums)
	answer := make([]int, n)

	// Инициализируем первый элемент answer как 1
	answer[0] = 1

	// Вычисляем префиксное произведение
	for i := 1; i < n; i++ {
		answer[i] = answer[i-1] * nums[i-1]
	}

	// Вычисляем суффиксное произведение и одновременно обновляем answer
	suffixProduct := 1
	for i := n - 1; i >= 0; i-- {
		answer[i] *= suffixProduct
		suffixProduct *= nums[i]
	}

	return answer
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q20">
                        Поиск в повернутом отсортированном массиве
                    </button>
                </h2>
                <div id="q20" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>search</code> выполняет поиск заданного элемента <code>target</code> в
                            повернутом отсортированном массиве <code>nums</code>.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация указателей <code>left</code> и <code>right</code> на начало и конец
                                массива
                            </li>
                            <li>Бинарный поиск с модификацией:
                                <ul>
                                    <li>Нахождение среднего элемента <code>mid</code></li>
                                    <li>Если <code>nums[mid] == target</code>, возвращаем <code>mid</code></li>
                                    <li>Определение, какая половина массива отсортирована:
                                        <ul>
                                            <li>Если левая половина отсортирована (<code>nums[left] <= nums[mid]</code>):
                                                <ul>
                                                    <li>Если <code>target</code> находится в левой половине, сужаем
                                                        поиск влево
                                                    </li>
                                                    <li>Иначе сужаем поиск вправо</li>
                                                </ul>
                                            </li>
                                            <li>Если правая половина отсортирована:
                                                <ul>
                                                    <li>Если <code>target</code> находится в правой половине, сужаем
                                                        поиск вправо
                                                    </li>
                                                    <li>Иначе сужаем поиск влево</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Если элемент не найден, возвращаем -1</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(log n)
                                <ul>
                                    <li>Используется модифицированный бинарный поиск</li>
                                    <li>На каждой итерации область поиска уменьшается вдвое</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется фиксированное количество дополнительных переменных</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func search(nums []int, target int) int {
	left, right := 0, len(nums)-1

	for left <= right {
		mid := left + (right-left)/2

		if nums[mid] == target {
			return mid
		}

		// Левая половина отсортирована
		if nums[left] <= nums[mid] {
			if target >= nums[left] && target < nums[mid] {
				right = mid - 1
			} else {
				left = mid + 1
			}
		} else { // Правая половина отсортирована
			if target > nums[mid] && target <= nums[right] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}

	return -1 // Элемент не найден
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q21">
                        Подсчет подмассивов с заданной суммой
                    </button>
                </h2>
                <div id="q21" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>subarraySum</code> подсчитывает количество подмассивов в заданном массиве
                            <code>nums</code>, сумма элементов которых равна заданному значению <code>k</code>.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>count</code> - счетчик подходящих подмассивов</li>
                                    <li><code>sum</code> - текущая кумулятивная сумма</li>
                                    <li><code>sumCounts</code> - карта для хранения количества встреченных кумулятивных
                                        сумм
                                    </li>
                                </ul>
                            </li>
                            <li>Итерация по элементам массива:
                                <ul>
                                    <li>Обновление кумулятивной суммы</li>
                                    <li>Проверка наличия комплементарной суммы <code>sum-k</code> в карте</li>
                                    <li>Увеличение счетчика на количество найденных комплементарных сумм</li>
                                    <li>Обновление количества текущей кумулятивной суммы в карте</li>
                                </ul>
                            </li>
                            <li>Возврат общего количества найденных подмассивов</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - количество элементов в массиве</li>
                                    <li>Один проход по всем элементам массива</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае, когда все кумулятивные суммы уникальны</li>
                                    <li>Использование карты для хранения кумулятивных сумм</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func subarraySum(nums []int, k int) int {
	count := 0
	sum := 0
	sumCounts := make(map[int]int)
	sumCounts[0] = 1 // Инициализируем для случая, когда подмассив начинается с начала массива

	for _, num := range nums {
		sum += num
		if cnt, exists := sumCounts[sum-k]; exists {
			count += cnt
		}
		sumCounts[sum]++
	}

	return count
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q22">
                        Подсчет подмассивов с суммой, делящейся на K
                    </button>
                </h2>
                <div id="q22" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>subarraysDivByK</code> подсчитывает количество подмассивов в заданном массиве
                            <code>nums</code>, сумма элементов которых делится на заданное число <code>k</code>.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>count</code> - карта для хранения количества встреченных остатков от
                                        деления
                                    </li>
                                    <li><code>sum</code> - текущая кумулятивная сумма</li>
                                    <li><code>result</code> - счетчик подходящих подмассивов</li>
                                </ul>
                            </li>
                            <li>Итерация по элементам массива:
                                <ul>
                                    <li>Обновление кумулятивной суммы</li>
                                    <li>Вычисление остатка от деления суммы на k (с обработкой отрицательных чисел)</li>
                                    <li>Увеличение результата на количество ранее встреченных подмассивов с таким же
                                        остатком
                                    </li>
                                    <li>Обновление количества текущего остатка в карте</li>
                                </ul>
                            </li>
                            <li>Возврат общего количества найденных подмассивов</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - количество элементов в массиве</li>
                                    <li>Один проход по всем элементам массива</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(min(n, k))
                                <ul>
                                    <li>В худшем случае хранятся k различных остатков в карте</li>
                                    <li>Количество уникальных остатков ограничено значением k</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func subarraysDivByK(nums []int, k int) int {
	count := make(map[int]int)
	count[0] = 1 // Инициализируем для случая, когда вся префиксная сумма делится на k
	sum := 0
	result := 0

	for _, num := range nums {
		sum += num
		remainder := (sum%k + k) % k // Обрабатываем отрицательные числа
		result += count[remainder]
		count[remainder]++
	}

	return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q23">
                        Точка равновесия массива
                    </button>
                </h2>
                <div id="q23" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Дан массив целых чисел. Необходимо найти в нем такой индекс, что сумма элементов слева от
                            него равна сумме элементов справа от него.
                            Если такого индекса нет, вернуть -1. Важно решить задачу за O(N) времени и за O(1) памяти.
                        </p>

                        <div class="example">
                            <p><b>Примеры:</b></p>
                            <p>Входной массив: <code>[1, 7, 3, 6, 5, 6]</code></p>
                            <p>Результат: <code>3</code> (сумма слева: 1+7+3=11, сумма справа: 5+6=11)</p>

                            <p>Входной массив: <code>[1, 2, 3]</code></p>
                            <p>Результат: <code>-1</code> (нет индекса равновесия)</p>
                        </div>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверяем, что массив не пуст. Если массив пуст, возвращаем -1.</li>
                            <li>Вычисляем общую сумму всех элементов массива.</li>
                            <li>Инициализируем переменную leftSum = 0 для хранения суммы элементов слева от текущего
                                индекса.
                            </li>
                            <li>Проходим по массиву и для каждого индекса i:
                                <ul>
                                    <li>Вычисляем сумму элементов справа как rightSum = totalSum - leftSum - nums[i]
                                    </li>
                                    <li>Проверяем, равна ли сумма элементов слева (leftSum) сумме элементов справа
                                        (rightSum)
                                    </li>
                                    <li>Если равна, возвращаем текущий индекс i</li>
                                    <li>Обновляем leftSum, добавляя к ней текущий элемент для следующей итерации</li>
                                </ul>
                            </li>
                            <li>Если после проверки всех индексов точка равновесия не найдена, возвращаем -1.</li>
                        </ol>
                        <p><strong>Временная сложность:</strong> O(N), где N - длина массива.</p>
                        <p>Мы делаем два прохода по массиву: один для вычисления общей суммы и один для поиска индекса
                            равновесия. Оба прохода линейны, поэтому общая временная сложность составляет O(N).</p>

                        <p><strong>Пространственная сложность:</strong> O(1).</p>
                        <p>Мы используем только несколько переменных (totalSum, leftSum, rightSum) независимо от размера
                            входного массива, поэтому пространственная сложность постоянна.</p>

                        <pre><code class="go">func FindEquilibriumIndex(nums []int) int {
    n := len(nums)
    if n == 0 {
        return -1
    }

    // Вычисляем общую сумму всех элементов
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }

    // Проходим по массиву и проверяем каждый индекс
    leftSum := 0
    for i := 0; i < n; i++ {
        // Правая сумма = общая сумма - левая сумма - текущий элемент
        rightSum := totalSum - leftSum - nums[i]

        // Если левая сумма равна правой, нашли индекс равновесия
        if leftSum == rightSum {
            return i
        }

        // Обновляем левую сумму для следующей итерации
        leftSum += nums[i]
    }

    // Если индекс равновесия не найден
    return -1
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q24">
                        Максимальный подотрезок с четной суммой
                    </button>
                </h2>
                <div id="q24" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Дан массив целых чисел. Необходимо найти максимальный по длине подотрезок (непрерывный
                            подмассив),
                            в котором сумма всех элементов является четным числом. Если таких подотрезков несколько,
                            нужно выбрать наибольший по длине. Если подотрезков с четной суммой нет, вернуть 0.
                        </p>

                        <div class="example">
                            <p><b>Примеры:</b></p>
                            <p>Входной массив: <code>[1, 2, 3, 4, 5]</code></p>
                            <p>Результат: <code>4</code> (подотрезок [2, 3, 4, 5] имеет сумму 14, которая четная)</p>

                            <p>Входной массив: <code>[2, 4, 6, 8]</code></p>
                            <p>Результат: <code>4</code> (весь массив имеет четную сумму 20)</p>

                            <p>Входной массив: <code>[1, 3, 5, 7]</code></p>
                            <p>Результат: <code>0</code> (нет подотрезков с четной суммой)</p>

                        </div>
                        <h3>Алгоритм решения</h3>
                        <p>
                            Алгоритм основан на следующем математическом наблюдении: если префиксные суммы двух
                            подмассивов
                            имеют одинаковый остаток при делении на 2, то сумма элементов между ними будет четной.
                        </p>
                        <ol>
                            <li>Проверяем, что массив не пуст. Если массив пуст, возвращаем 0.</li>
                            <li>Создаем карту для хранения индекса первого вхождения каждого остатка от деления
                                префиксной суммы на 2.
                            </li>
                            <li>Инициализируем карту с остатком 0 и индексом -1 (это нужно для обработки случая, когда
                                префиксная сумма сама по себе четная).
                            </li>
                            <li>Проходим по массиву, накапливая текущую сумму и вычисляя остаток от деления на 2.</li>
                            <li>Для каждой позиции проверяем:
                                <ul>
                                    <li>Если текущий остаток уже встречался ранее, значит между текущей позицией и
                                        первым вхождением этого остатка сумма четная.
                                    </li>
                                    <li>Вычисляем длину этого подотрезка и обновляем максимальную длину.</li>
                                    <li>Если остаток встречается впервые, запоминаем его позицию.</li>
                                </ul>
                            </li>
                            <li>Возвращаем найденную максимальную длину.</li>
                        </ol>
                        <p><strong>Временная сложность:</strong> O(N), где N - длина массива.</p>
                        <p>Мы делаем один проход по массиву, и все операции внутри цикла (доступ к карте, вычисление
                            остатка) выполняются за O(1).</p>

                        <p><strong>Пространственная сложность:</strong> O(1).</p>
                        <p>Несмотря на использование карты, в ней будет максимум 2 элемента (для остатков 0 и 1),
                            поэтому пространственная сложность константна.</p>


                        <pre><code class="go">func FindMaxEvenSubsegment(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }

    // Храним индекс первого вхождения остатка от деления на 2
    // Для четной суммы (остаток 0) и нечетной суммы (остаток 1)
    firstOccurrence := map[int]int{
        0: -1, // Инициализируем для четной суммы как -1 (до начала массива)
    }

    maxLength := 0
    currentSum := 0

    for i := 0; i < n; i++ {
        // Обновляем текущую сумму и вычисляем остаток от деления на 2
        currentSum += nums[i]
        remainder := currentSum % 2

        // Если такой остаток уже встречался, значит между текущей позицией
        // и первым вхождением этого остатка сумма четная
        if idx, exists := firstOccurrence[remainder]; exists {
            length := i - idx
            maxLength = max(maxLength, length)
        } else {
            // Запоминаем первое вхождение этого остатка
            firstOccurrence[remainder] = i
        }
    }

    return maxLength
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q24-2">
                        Максимальный подотрезок с ограниченной разницей
                    </button>
                </h2>
                <div id="q24-2" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Дан массив целых положительных чисел и число k. Требуется найти максимальный по длине
                            подмассив, в котором разница между максимальным и минимальным элементом не превышает k.</p>

                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализируем два указателя: left и right, определяющие текущий подмассив.</li>
                            <li>Создаем два монотонных стека: minStack для минимальных элементов и maxStack для
                                максимальных.
                            </li>
                            <li>Двигаем правый указатель right по массиву:
                                <ul>
                                    <li>Обновляем minStack, удаляя элементы, большие текущего.</li>
                                    <li>Обновляем maxStack, удаляя элементы, меньшие текущего.</li>
                                    <li>Добавляем текущий индекс в оба стека.</li>
                                </ul>
                            </li>
                            <li>Если разница между максимальным и минимальным элементом превышает k:
                                <ul>
                                    <li>Двигаем левый указатель left вправо.</li>
                                    <li>Обновляем стеки, удаляя элементы, вышедшие за пределы текущего окна.</li>
                                </ul>
                            </li>
                            <li>Обновляем максимальную длину подмассива.</li>
                            <li>Повторяем шаги 3-5, пока не достигнем конца массива.</li>
                        </ol>

                        <ul>
                            <li>Использование монотонных стеков позволяет эффективно отслеживать минимальные и
                                максимальные элементы в текущем окне.
                            </li>
                            <li>Алгоритм работает за линейное время, что делает его эффективным для больших массивов.
                            </li>
                            <li>Решение использует технику "скользящего окна" с динамическим изменением его размера.
                            </li>
                            <li>Подход позволяет решить задачу за один проход по массиву.</li>
                        </ul>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n), где n - длина входного массива. Каждый
                                элемент добавляется и удаляется из стеков не более одного раза.
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n) в худшем случае, когда все элементы
                                могут оказаться в стеках.
                            </li>
                        </ul>


                        <pre><code class="go">func maxSubarrayWithDiffK(arr []int, k int) int {
	n := len(arr)
	maxLen := 0
	left := 0
	minStack := []int{}
	maxStack := []int{}

	for right := 0; right < n; right++ {
		// Обновляем минимальный стек
		for len(minStack) > 0 && arr[minStack[len(minStack)-1]] > arr[right] {
			minStack = minStack[:len(minStack)-1]
		}
		minStack = append(minStack, right)

		// Обновляем максимальный стек
		for len(maxStack) > 0 && arr[maxStack[len(maxStack)-1]] < arr[right] {
			maxStack = maxStack[:len(maxStack)-1]
		}
		maxStack = append(maxStack, right)

		// Проверяем разницу между максимальным и минимальным элементом
		for arr[maxStack[0]]-arr[minStack[0]] > k {
			left++
			if left > minStack[0] {
				minStack = minStack[1:]
			}
			if left > maxStack[0] {
				maxStack = maxStack[1:]
			}
		}

		// Обновляем максимальную длину
		maxLen = max(maxLen, right-left+1)
	}

	return maxLen
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q25">
                        Сумма трех чисел, ближайшая к целевому значению
                    </button>
                </h2>
                <div id="q25" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Дан массив целых чисел <code>nums</code> и целевое значение <code>target</code>. Необходимо
                            найти такую тройку
                            чисел в массиве с различными индексами, что их сумма наиболее близка к целевому значению
                            <code>target</code>.
                            Требуется вернуть саму сумму трех чисел.
                        </p>

                        <div class="example">
                            <h3>Примеры:</h3>
                            <p><strong>Пример 1:</strong></p>
                            <p>Вход: <code>nums = [-1, 2, 1, -4]</code>, <code>target = 1</code></p>
                            <p>Выход: <code>2</code></p>
                            <p>Пояснение: Сумма <code>-1 + 2 + 1 = 2</code> наиболее близка к целевому значению 1.</p>

                            <p><strong>Пример 2:</strong></p>
                            <p>Вход: <code>nums = [0, 0, 0]</code>, <code>target = 1</code></p>
                            <p>Выход: <code>0</code></p>
                            <p>Пояснение: Сумма <code>0 + 0 + 0 = 0</code> наиболее близка к целевому значению 1.</p>
                        </div>
                        <h3>Алгоритм решения</h3>
                        <p>
                            Для решения этой задачи используется подход с сортировкой массива и техникой двух
                            указателей:
                        </p>
                        <ol>
                            <li>Проверяем, что в массиве достаточно элементов (не менее 3). Если элементов меньше,
                                возвращаем 0.
                            </li>
                            <li>Сортируем массив для эффективного поиска с помощью двух указателей.</li>
                            <li>Инициализируем переменную <code>closestSum</code> начальным значением (сумма первых трех
                                элементов).
                            </li>
                            <li>Вычисляем начальную минимальную разницу <code>minDiff</code> между
                                <code>closestSum</code> и целевым значением.
                            </li>
                            <li>Перебираем первый элемент тройки в цикле:
                                <ul>
                                    <li>Пропускаем дубликаты для оптимизации (если текущий элемент равен предыдущему).
                                    </li>
                                    <li>Устанавливаем два указателя: <code>left</code> (сразу после текущего элемента) и
                                        <code>right</code> (конец массива).
                                    </li>
                                    <li>Пока <code>left</code> < <code>right</code>:
                                        <ul>
                                            <li>Вычисляем текущую сумму трех элементов: <code>nums[i] + nums[left] +
                                                nums[right]</code>.
                                            </li>
                                            <li>Вычисляем разницу между текущей суммой и целевым значением.</li>
                                            <li>Если нашли точное совпадение (разница = 0), сразу возвращаем
                                                результат.
                                            </li>
                                            <li>Если текущая разница меньше минимальной, обновляем <code>minDiff</code>
                                                и <code>closestSum</code>.
                                            </li>
                                            <li>Двигаем указатели: если текущая сумма меньше целевого значения,
                                                увеличиваем <code>left</code>, иначе уменьшаем <code>right</code>.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Возвращаем найденную ближайшую сумму <code>closestSum</code>.</li>
                        </ol>
                        <p><strong>Временная сложность:</strong> O(n²), где n - размер массива.</p>
                        <p>Сортировка массива занимает O(n log n), а алгоритм с двумя указателями требует O(n²) операций
                            в худшем случае.</p>

                        <p><strong>Пространственная сложность:</strong> O(log n) или O(1), в зависимости от реализации
                            сортировки.</p>
                        <p>Помимо входного массива, мы используем только константное количество дополнительных
                            переменных.</p>

                        <pre><code class="go">func ThreeSumClosest(nums []int, target int) int {
    n := len(nums)
    if n < 3 {
        return 0 // Недостаточно элементов
    }

    // Сортируем массив для использования двух указателей
    sort.Ints(nums)

    // Инициализируем переменную для хранения ближайшей суммы
    // с максимально возможным значением разницы
    closestSum := nums[0] + nums[1] + nums[2]
    minDiff := math.Abs(float64(closestSum - target))

    // Перебираем первый элемент тройки
    for i := 0; i < n-2; i++ {
        // Пропускаем дубликаты для первого элемента
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        // Используем два указателя для поиска оставшихся двух элементов
        left, right := i+1, n-1

        for left < right {
            currentSum := nums[i] + nums[left] + nums[right]
            currentDiff := math.Abs(float64(currentSum - target))

            // Если нашли точное совпадение, сразу возвращаем результат
            if currentSum == target {
                return currentSum
            }

            // Обновляем ближайшую сумму, если текущая разница меньше
            if currentDiff < minDiff {
                minDiff = currentDiff
                closestSum = currentSum
            }

            // Двигаем указатели в зависимости от текущей суммы
            if currentSum < target {
                left++
            } else {
                right--
            }
        }
    }

    return closestSum
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q26">
                        Минимальная абсолютная разница между элементами двух массивов
                    </button>
                </h2>
                <div id="q26" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Даны два массива целых чисел A и B. Необходимо найти минимальное значение абсолютной разницы
                            |A[i] - B[j]| между любыми элементами этих массивов.
                        </p>

                        <div class="example">
                            <h3>Примеры:</h3>
                            <p><strong>Пример 1:</strong></p>
                            <p>Вход: A = {0}, B = {1}</p>
                            <p>Выход: 1</p>
                            <p>Пояснение: Единственная возможная разница |0-1| = 1.</p>

                            <p><strong>Пример 2:</strong></p>
                            <p>Вход: A = {10, 0, 2}, B = {5, 100, 12}</p>
                            <p>Выход: 2</p>
                            <p>Пояснение: Минимальная абсолютная разница достигается для пары (10, 12): |10-12| = 2.</p>
                        </div>
                        <h3>Алгоритм решения</h3>
                        <p>
                            Для решения этой задачи мы будем использовать алгоритм двух указателей на отсортированных
                            массивах.
                            Основная идея:
                        </p>
                        <ol>
                            <li>Сортируем оба массива A и B</li>
                            <li>Устанавливаем два указателя: i на начало массива A и j на начало массива B</li>
                            <li>Пока оба указателя не достигли конца своих массивов:
                                <ul>
                                    <li>Вычисляем абсолютную разницу между текущими элементами |A[i] - B[j]|</li>
                                    <li>Обновляем минимальную разницу, если нашли меньшую</li>
                                    <li>Двигаем указатель на массив с меньшим текущим элементом</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Временная сложность:</strong> O(n log n + m log m), где n и m - размеры массивов A и
                            B соответственно.</p>
                        <ul>
                            <li>Сортировка массива A: O(n log n)</li>
                            <li>Сортировка массива B: O(m log m)</li>
                            <li>Проход по массивам с двумя указателями: O(n + m)</li>
                        </ul>
                        <p><strong>Пространственная сложность:</strong> O(1) дополнительной памяти (не считая входных
                            массивов).</p>

                        <pre><code class="go">func FindMinAbsDifference(A, B []int) int {
    if len(A) == 0 || len(B) == 0 {
        return 0
    }

    // Сортируем оба массива
    sort.Ints(A)
    sort.Ints(B)

    minDiff := math.MaxInt32
    i, j := 0, 0

    // Используем два указателя для прохода по массивам
    for i < len(A) && j < len(B) {
        diff := int(math.Abs(float64(A[i] - B[j])))
        minDiff = min(minDiff, diff)

        // Двигаем указатель на меньший элемент
        if A[i] < B[j] {
            i++
        } else {
            j++
        }
    }

    return minDiff
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q27">
                        Поиск элемента в циклически сдвинутом отсортированном массиве
                    </button>
                </h2>
                <div id="q27" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Дан отсортированный по возрастанию массив уникальных целых чисел, который был циклически
                            сдвинут на неизвестное количество позиций. Требуется найти индекс заданного элемента в этом
                            массиве или вернуть -1, если элемент отсутствует.</p>

                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Найти точку сдвига в массиве с помощью бинарного поиска.</li>
                            <li>Выполнить бинарный поиск на всем массиве, учитывая сдвиг при вычислении среднего
                                элемента.
                            </li>
                        </ol>
                        <ul>
                            <li>Временная сложность: O(log N), где N - количество элементов в массиве.</li>
                            <li>Пространственная сложность: O(1), используется константное дополнительное
                                пространство.
                            </li>
                        </ul>

                        <pre><code class="go">func findTarget(nums []int, target int) int {
    if len(nums) == 0 {
        return -1
    }

    // Находим точку сдвига
    k := findShiftPoint(nums)

    // Выполняем бинарный поиск на всем массиве
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        realMid := (mid + k) % len(nums)  // Учитываем сдвиг

        if nums[realMid] == target {
            return realMid
        }

        if nums[realMid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return -1
}

// Находит точку сдвига в массиве
func findShiftPoint(nums []int) int {
    left, right := 0, len(nums)-1

    // Если массив не был сдвинут
    if nums[left] < nums[right] {
        return 0
    }

    for left <= right {
        mid := left + (right-left)/2

        // Проверяем, является ли mid точкой сдвига
        if mid < len(nums)-1 && nums[mid] > nums[mid+1] {
            return mid + 1
        }

        if nums[mid] >= nums[0] {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return 0
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q28">
                        Подсчет общих префиксов в двух массивах
                    </button>
                </h2>
                <div id="q28" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Даны два массива целых чисел A и B одинаковой длины N. Для каждого K от 1 до N необходимо
                            подсчитать количество чисел, которые встречаются как в первых K элементах массива A, так и в
                            первых K элементах массива B. Результат нужно вернуть в виде массива длины N+1, где элемент
                            с индексом K содержит количество общих чисел для первых K элементов обоих массивов.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализировать массив результатов и хеш-таблицу для отслеживания встречаемости
                                чисел.
                            </li>
                            <li>Для каждого K от 1 до N:
                                <ul>
                                    <li>Обновить хеш-таблицу для K-го элемента массива A.</li>
                                    <li>Обновить хеш-таблицу для K-го элемента массива B.</li>
                                    <li>Подсчитать количество общих элементов для первых K элементов.</li>
                                    <li>Записать результат в массив результатов.</li>
                                </ul>
                            </li>
                            <li>Вернуть массив результатов.</li>
                        </ol>
                        <ul>
                            <li>Временная сложность: O(N), где N - длина массивов.</li>
                            <li>Пространственная сложность: O(N) для хранения хеш-таблицы и массива результатов.</li>
                        </ul>

                        <pre><code class="go">func countCommonPrefixes(a, b []int) []int {
    n := len(a)
    result := make([]int, n+1)
    has := make(map[int]int)

    for k := 1; k <= n; k++ {
        // Обновляем хеш-таблицу для текущего элемента a[k-1]
        if _, exists := has[a[k-1]]; !exists {
            has[a[k-1]] = 0
        }
        if has[a[k-1]] == 1 {
            has[a[k-1]] = 2
        } else {
            has[a[k-1]] = 0
        }

        // Обновляем хеш-таблицу для текущего элемента b[k-1]
        if _, exists := has[b[k-1]]; !exists {
            has[b[k-1]] = 1
        }
        if has[b[k-1]] == 0 {
            has[b[k-1]] = 2
        }

        // Подсчитываем общие элементы
        count := 0
        for i := 0; i < k; i++ {
            if has[a[i]] == 2 {
                count++
            }
        }
        result[k] = count
    }

    return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q29">
                        Сжатие числового массива
                    </button>
                </h2>
                <div id="q29" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Дан массив целых чисел. Необходимо "сжать" его, представив последовательные числа в виде
                            диапазонов.
                            Каждый диапазон должен быть представлен либо одним числом (если диапазон состоит из одного
                            числа),
                            либо парой чисел (начало и конец диапазона). Результат должен быть представлен в виде
                            массива массивов.
                        </p>
                        <p>
                            Вход: [-3, -10, 1, -2, 2, 3, 5]<br>
                            Выход: [[-10], [-3, -2], [1, 3], [5]]
                        </p>

                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Создать словарь (map) для хранения всех уникальных чисел из входного массива.</li>
                            <li>Пока словарь не пуст:
                                <ul>
                                    <li>Выбрать произвольное число из словаря.</li>
                                    <li>Найти максимальный непрерывный диапазон чисел, содержащих выбранное число.</li>
                                    <li>Добавить найденный диапазон в результат.</li>
                                    <li>Удалить все числа найденного диапазона из словаря.</li>
                                </ul>
                            </li>
                            <li>Вернуть полученный результат.</li>
                        </ol>
                        <p>
                            Временная сложность: O(n), где n - количество элементов в исходном массиве.<br>
                            Пространственная сложность: O(n) для хранения словаря и результата.
                        </p>

                        <pre><code class="go">func CompressArray(arr []int) [][]int {
    // Создаем словарь для хранения элементов массива
    dict := make(map[int]bool)
    for _, num := range arr {
        dict[num] = true
    }

    result := [][]int{}

    for len(dict) > 0 {
        // Выбираем произвольный ключ из словаря
        var key int
        for k := range dict {
            key = k
            break
        }

        // Ищем максимальные l и r
        l, r := key, key
        for dict[l-1] {
            l--
        }
        for dict[r+1] {
            r++
        }

        // Добавляем результат
        if l == r {
            result = append(result, []int{l})
        } else {
            result = append(result, []int{l, r})
        }

        // Удаляем найденные числа из словаря
        for i := l; i <= r; i++ {
            delete(dict, i)
        }
    }

    return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q30">
                        Подсчет подпоследовательностей в массиве
                    </button>
                </h2>
                <div id="q30" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Даны два массива целых чисел: <code>a</code> и <code>b</code>. Необходимо найти количество
                            подотрезков массива <code>a</code>,
                            которые являются подпоследовательностями массива <code>b</code>.
                        </p>

                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализируем счетчик <code>count</code> для подсчета подходящих подотрезков.</li>
                            <li>Перебираем все возможные левые границы <code>l</code> в массиве <code>a</code>.</li>
                            <li>Для каждой левой границы:
                                <ul>
                                    <li>Инициализируем счетчик <code>cnt</code> для отслеживания совпадений с элементами
                                        <code>b</code>.
                                    </li>
                                    <li>Проходим по элементам <code>a</code>, начиная с позиции <code>l</code>,
                                        сравнивая их с элементами <code>b</code>.
                                    </li>
                                    <li>Если находим совпадение, увеличиваем <code>cnt</code> и переходим к следующему
                                        элементу <code>b</code>.
                                    </li>
                                    <li>Если <code>cnt</code> достигает длины <code>b</code>, значит, мы нашли полную
                                        подпоследовательность:
                                        <ul>
                                            <li>Добавляем к <code>count</code> количество оставшихся элементов в
                                                <code>a</code>.
                                            </li>
                                            <li>Прерываем внутренний цикл и переходим к следующей левой границе.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Возвращаем итоговое значение <code>count</code>.</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n * m), где n - длина массива a, m - длина
                                массива b.
                                В худшем случае, для каждого элемента a мы можем пройти по всем элементам b.
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1), так как мы используем только
                                несколько
                                дополнительных переменных, независимо от размера входных данных.
                            </li>
                        </ul>

                        <pre><code class="go">func countSubarrays(a, b []int) int {
	count := 0
	n := len(a)
	m := len(b)

	for l := 0; l < n; l++ {
		cnt := 0
		for i, j := l, 0; i < n && j < m; i++ {
			if a[i] == b[j] {
				j++
				cnt++
			}
			if cnt == m {
				count += n - i
				break
			}
		}
	}

	return count
}
</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q31">
                        Поиск нуля с максимальным расстоянием до ближайшей единицы
                    </button>
                </h2>
                <div id="q31" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Дан массив, состоящий только из нулей и единиц. Гарантируется, что в массиве есть хотя бы
                            один ноль и одна единица.
                            Необходимо найти позицию нуля, у которого расстояние до ближайшей единицы максимально.
                        </p>

                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализируем переменные:
                                <ul>
                                    <li><code>lastOne</code>: позиция последней встреченной единицы (изначально -1)</li>
                                    <li><code>maxDistance</code>: максимальное найденное расстояние</li>
                                    <li><code>result</code>: позиция нуля с максимальным расстоянием</li>
                                </ul>
                            </li>
                            <li>Проходим по массиву слева направо:
                                <ul>
                                    <li>Если встречаем единицу:
                                        <ul>
                                            <li>Если это первая единица, обрабатываем случай начальных нулей</li>
                                            <li>Иначе вычисляем расстояние до предыдущей единицы</li>
                                            <li>Если новое расстояние больше максимального, обновляем
                                                <code>maxDistance</code> и <code>result</code></li>
                                        </ul>
                                    </li>
                                    <li>Обновляем позицию последней единицы</li>
                                </ul>
                            </li>
                            <li>После прохода проверяем случай конечных нулей</li>
                            <li>Возвращаем найденную позицию нуля</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n), где n - длина массива.
                                Алгоритм проходит по массиву ровно один раз.
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1), так как используется
                                фиксированное количество дополнительных переменных, независимо от размера входных
                                данных.
                            </li>
                        </ul>

                        <pre><code class="go">func findMaxDistanceZero(arr []int) int {
	n := len(arr)
	lastOne := -1
	maxDistance := 0
	result := 0

	for i := 0; i < n; i++ {
		if arr[i] == 1 {
			if lastOne == -1 {
				// Обработка случая, когда последовательность начинается с нуля
				maxDistance = i
				result = 0
			} else {
				// Вычисление расстояния между текущей единицей и предыдущей
				distance := (i - lastOne) / 2
				if distance > maxDistance {
					maxDistance = distance
					result = lastOne + distance
				}
			}
			lastOne = i
		}
	}

	// Обработка случая, когда последовательность заканчивается нулем
	if n-1-lastOne > maxDistance {
		result = n - 1
	}

	return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q32">
                        Минимальное произведение двух уникальных чисел
                    </button>
                </h2>
                <div id="q32" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Дан массив целых чисел длины n > 1. Необходимо найти минимальное произведение, которое можно
                            получить из двух чисел массива с уникальными позициями.</p>


                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверяем длину массива. Если она меньше или равна 1, возвращаем 0, так как невозможно
                                выбрать два уникальных числа.
                            </li>
                            <li>Инициализируем переменные для хранения двух максимальных (max1, max2) и двух минимальных
                                (min1, min2) чисел.
                            </li>
                            <li>Проходим по массиву один раз, обновляя значения max1, max2, min1 и min2.</li>
                            <li>После прохода по массиву проверяем три условия:
                                <ul>
                                    <li>Если min1 ≤ 0 и max1 ≥ 0, возвращаем min1 * max1 (случай с отрицательными и
                                        неотрицательными числами).
                                    </li>
                                    <li>Если min1 > 0 (все числа положительные), возвращаем min1 * min2.</li>
                                    <li>В противном случае (все числа отрицательные), возвращаем max1 * max2.</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n), где n - длина входного массива. Мы проходим
                                по массиву только один раз.
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1), так как мы используем фиксированное
                                количество дополнительных переменных независимо от размера входного массива.
                            </li>
                        </ul>

                        <pre><code class="go">func minProduct(arr []int) int {
	if len(arr) <= 1 {
		return 0 // Невозможно выбрать два уникальных числа
	}

	max1, max2 := math.MinInt32, math.MinInt32
	min1, min2 := math.MaxInt32, math.MaxInt32

	for _, num := range arr {
		// Обновляем максимальные числа
		if num > max1 {
			max2 = max1
			max1 = num
		} else if num > max2 {
			max2 = num
		}

		// Обновляем минимальные числа
		if num < min1 {
			min2 = min1
			min1 = num
		} else if num < min2 {
			min2 = num
		}
	}

	// Проверяем условия и возвращаем результат
	if min1 <= 0 && max1 >= 0 {
		return min1 * max1
	} else if min1 > 0 {
		return min1 * min2
	} else {
		return max1 * max2
	}
}
</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q33">
                        Подсчет непересекающихся отрезков
                    </button>
                </h2>
                <div id="q33" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Дано N пар чисел a_i и b_i, представляющих отрезки на числовой прямой от (a_i, 0) до (1,
                            b_i). Требуется найти количество отрезков, которые не пересекаются с другими отрезками в
                            этом
                            множестве.</p>

                        <h2>Алгоритм решения</h2>
                        <ol>
                            <li>Создаем структуру Segment для представления отрезков с полями a и b.</li>
                            <li>Формируем слайс отрезков из входных данных a и b.</li>
                            <li>Сортируем отрезки по возрастанию координаты a (начальной точки).</li>
                            <li>Инициализируем счетчик непересекающихся отрезков (count) и переменную для хранения
                                максимальной конечной точки (maxB).
                            </li>
                            <li>Проходим по отсортированному массиву отрезков слева направо:
                                <ul>
                                    <li>Если конечная точка текущего отрезка (b) больше maxB, увеличиваем count и
                                        обновляем maxB.
                                    </li>
                                </ul>
                            </li>
                            <li>Возвращаем значение count как результат.</li>
                        </ol>

                        <ul>
                            <li><strong>Временная сложность:</strong> O(N log N), где N - количество отрезков. Основной
                                вклад вносит сортировка отрезков.
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(N) для хранения отсортированного массива
                                отрезков.
                            </li>
                        </ul>

                        <pre><code class="go">type Segment struct {
	a, b int
}

func countNonIntersectingSegments(a, b []int) int {
	n := len(a)
	segments := make([]Segment, n)
	for i := 0; i < n; i++ {
		segments[i] = Segment{a[i], b[i]}
	}

	// Сортируем отрезки по координате a
	sort.Slice(segments, func(i, j int) bool {
		return segments[i].a < segments[j].a
	})

	count := 0
	maxB := 0

	for i := 0; i < n; i++ {
		if segments[i].b > maxB {
			count++
			maxB = segments[i].b
		}
	}

	return count
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q34">
                        Оптимальное размещение нуля в бинарном массиве
                    </button>
                </h2>
                <div id="q34" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Дан массив, состоящий только из 0 и 1. Требуется найти такую позицию для размещения нуля,
                            чтобы минимальное расстояние до ближайшей единицы было максимальным.</p>

                        <h2>Алгоритм решения</h2>
                        <ol>
                            <li>Инициализируем переменные:
                                <ul>
                                    <li><code>lastOne</code>: индекс последней встреченной единицы (изначально -1)</li>
                                    <li><code>maxDistance</code>: максимальное найденное расстояние</li>
                                    <li><code>optimalPosition</code>: оптимальная позиция для нуля</li>
                                </ul>
                            </li>
                            <li>Проходим по массиву слева направо:
                                <ul>
                                    <li>Если встречаем 1:
                                        <ul>
                                            <li>Если это первая единица, сравниваем расстояние от начала массива</li>
                                            <li>Иначе вычисляем расстояние между текущей и предыдущей единицей</li>
                                        </ul>
                                    </li>
                                    <li>Обновляем <code>maxDistance</code> и <code>optimalPosition</code>, если найдено
                                        большее расстояние
                                    </li>
                                    <li>Обновляем <code>lastOne</code></li>
                                </ul>
                            </li>
                            <li>После прохода проверяем расстояние от последней единицы до конца массива</li>
                            <li>Возвращаем <code>optimalPosition</code></li>
                        </ol>

                        <ul>
                            <li><strong>Временная сложность:</strong> O(n), где n - длина входного массива. Алгоритм
                                проходит по массиву ровно один раз.
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1), так как используется только
                                фиксированное количество дополнительных переменных, независимо от размера входного
                                массива.
                            </li>
                        </ul>

                        <pre><code class="go">func findOptimalZeroPosition(arr []int) int {
    n := len(arr)
    lastOne := -1
    maxDistance := 0
    optimalPosition := 0

    for i := 0; i < n; i++ {
        if arr[i] == 1 {
            if lastOne == -1 {
                // Первая единица в массиве
                if i > maxDistance {
                    maxDistance = i
                    optimalPosition = 0
                }
            } else {
                // Расстояние между текущей и предыдущей единицей
                distance := (i - lastOne) / 2
                if distance > maxDistance {
                    maxDistance = distance
                    optimalPosition = (i + lastOne) / 2
                }
            }
            lastOne = i
        }
    }

    // Проверяем расстояние от последней единицы до конца массива
    if n - 1 - lastOne > maxDistance {
        maxDistance = n - 1 - lastOne
        optimalPosition = n - 1
    }

    return optimalPosition
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>
</body>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
</html>