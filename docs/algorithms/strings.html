<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Архитектура - Строки</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
<div class="container">
    <header>
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">DevInterview</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="nav-link" href="./php.html">PHP - вопросы</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./php_tasks.html">PHP - задачи</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./go.html">Go - вопросы</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./go_tasks.html">Go - задачи</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./db.html">Базы данных</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./architecture.html">Архитектура</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="../algorithms.html">Алгоритмы</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <main>
        <h1>Алгоритмы - Строки</h1>
        <div class="accordion" id="accordionBlock">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q1">
                        Анаграмма
                    </button>
                </h2>
                <div id="q1" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Этот код решает задачу проверки, являются ли две строки анаграммами друг друга. <br/>
                            Анаграммы - это слова или фразы, состоящие из одних и тех же букв, но в разном порядке.
                        </p>
                        <h3>Алгоритм решения </h3>

                        <ol>
                            <li>Сначала проверяется, равны ли длины строк. Если нет, то они не могут
                                быть анаграммами.
                            </li>
                            <li>Создаются два словаря (map) для подсчета частоты встречаемости каждого
                                символа в обеих строках.
                            </li>
                            <li>Проходим по первой строке и заполняем первый словарь.</li>
                            <li>Проходим по второй строке и заполняем второй словарь.</li>
                            <li>Сравниваем частоты символов в обоих словарях. Если для какого-то символа
                                частоты не совпадают, строки не являются анаграммами.
                            </li>
                            <li>Если все проверки пройдены успешно, строки являются анаграммами.</li>
                        </ol>
                        <p>
                            Временная сложность: O(n), где n - длина строк. Это происходит потому, что
                            мы проходим по каждой строке один раз для заполнения словарей, а затем еще
                            раз проходим по словарю для сравнения.</p>
                        <p>Пространственная сложность: O(k), где k - размер алфавита (количество
                            уникальных символов в строках). В худшем случае, когда все символы в строках
                            уникальны, это может быть O(n), но обычно k намного меньше n.
                        </p>
                        <pre><code class="go">func isAnagram(s1, s2 string) bool {
    if len(s1) != len(s2) {
    return false
    }

    s1Rune := make(map[rune]int)
    s2Rune := make(map[rune]int)

    for _, r := range s1 {
    s1Rune[r]++
    }

    for _, r := range s2 {
    s2Rune[r]++
    }

    for r, count := range s1Rune {
    if count != s2Rune[r] {
    return false
    }
    }

    return true
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q2">
                        Индекс первого вхождения подстроки
                    </button>
                </h2>
                <div id="q2" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>
                            Этот код реализует функцию strStr, которая решает задачу нахождения индекса первого
                            вхождения подстроки (needle) в строку (haystack). Это аналог функции indexOf в некоторых
                            языках программирования.
                        </p>
                        <h3>Алгоритм решения </h3>
                        <ol>
                            <li>
                                Проверяем краевые случаи:
                                <ul>
                                    <li>Если needle пустая, возвращаем 0 (пустая строка всегда считается найденной в
                                        начале любой строки).
                                    </li>
                                    <li>Если haystack короче needle, возвращаем -1 (невозможно найти).</li>
                                </ul>
                            </li>
                            <li>
                                Проходим по строке haystack, используя скользящее окно размером с needle:
                                <ul>
                                    <li>Для каждой позиции i в haystack проверяем, совпадает ли подстрока
                                        haystack[i:i+len(needle)] с needle.
                                    </li>
                                    <li>Если совпадение найдено, возвращаем индекс i.</li>
                                </ul>
                            </li>
                            <li>
                                Если после прохода по всей строке совпадение не найдено, возвращаем -1.
                            </li>
                        </ol>
                        <p>
                            Временная сложность: O(n * m), где n - длина haystack, m - длина needle.</p>
                        <p>Пространственная сложность: O(1), так как используется только фиксированное количество
                            дополнительных переменных, независимо от размера входных строк.
                        </p>
                        <pre><code class="go">func strStr(haystack string, needle string) int {
	if len(needle) == 0 {
		return 0
	}

	if len(haystack) < len(needle) {
		return -1
	}

	for i := 0; i <= len(haystack)-len(needle); i++ {
		if haystack[i:i+len(needle)] == needle {
			return i
		}
	}

	return -1
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q3">
                        Генерация всех возможных комбинаций скобочек
                    </button>
                </h2>
                <div id="q3" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код генерирует все возможные правильные скобочные последовательности заданной длины n.
                            Правильная скобочная последовательность - это строка, содержащая только скобки '(' и ')',
                            где каждая открывающая скобка имеет соответствующую закрывающую, и они правильно
                            вложены.</p>

                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Функция <code>generateScobs</code> инициализирует пустой слайс для результатов и
                                вызывает вспомогательную рекурсивную функцию.
                            </li>
                            <li>Функция <code>generateHelper</code> использует рекурсию с бэктрекингом:
                                <ul>
                                    <li>Базовый случай: если все скобки использованы, добавляем текущую
                                        последовательность в результат.
                                    </li>
                                    <li>Рекурсивные случаи:
                                        <ul>
                                            <li>Если есть неиспользованные открывающие скобки, добавляем '(' и
                                                рекурсивно вызываем функцию.
                                            </li>
                                            <li>Если закрывающих скобок осталось больше, чем открывающих, добавляем ')'
                                                и рекурсивно вызываем функцию.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(4^n / √n)
                                <ul>
                                    <li>Это приближение n-го числа Каталана, которое определяет количество правильных
                                        скобочных последовательностей.
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>Обусловлена глубиной рекурсии и длиной хранимых строк.</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func generateScobs(n int) []string {
	result := make([]string, 0)
	generateHelper(n, n, n, &result, "")
	return result
}

func generateHelper(n, left, right int, result *[]string, current string) {
	if left == 0 && right == 0 && current != "" {
		*result = append(*result, current)
		return
	}

	if left > 0 {
		generateHelper(n, left-1, right, result, current+"(")
	}

	if right > left {
		generateHelper(n, left, right-1, result, current+")")
	}
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q4">
                        Проверка подпоследовательности
                    </button>
                </h2>
                <div id="q4" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>isSubsequence</code>, которая проверяет, является ли строка
                            <code>s</code> подпоследовательностью строки <code>t</code>. Подпоследовательность - это
                            последовательность символов, которая появляется в той же последовательности в другой строке,
                            но не обязательно непрерывно.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка краевых случаев:
                                <ul>
                                    <li>Если <code>s</code> пустая или равна <code>t</code>, возвращаем true.</li>
                                    <li>Если <code>s</code> длиннее <code>t</code>, или они равной длины, но не равны,
                                        или <code>t</code> пустая, возвращаем false.
                                    </li>
                                </ul>
                            </li>
                            <li>Преобразование строк в слайсы рун для корректной обработки Unicode-символов.</li>
                            <li>Итерация по символам строки <code>t</code>:
                                <ul>
                                    <li>Если текущий символ совпадает с символом в <code>s</code> на позиции курсора,
                                        увеличиваем курсор.
                                    </li>
                                    <li>Если курсор достиг конца <code>s</code>, возвращаем true (вся
                                        подпоследовательность найдена).
                                    </li>
                                </ul>
                            </li>
                            <li>Если после прохода по всей строке <code>t</code> не все символы <code>s</code> найдены,
                                возвращаем false.
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(t), где t - длина строки t
                                <ul>
                                    <li>В худшем случае алгоритм проходит по всей строке t один раз.</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(m+n), где m и n - длины строк s и t
                                соответственно
                                <ul>
                                    <li>Создаются два новых слайса рун для хранения символов обеих строк.</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func isSubsequence(s string, t string) bool {
	if s == t || s == "" {
		return true
	}
	if len(s) > len(t) || t == "" {
		return false
	}

	rS := []rune(s)
	rT := []rune(t)

	cursor := 0
	for _, c := range rT {
		if rS[cursor] == c {
			cursor++
		}

		if cursor == len(rS) {
			return true
		}
	}

	return false
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q5">
                        Проверка корректности скобочной последовательности
                    </button>
                </h2>
                <div id="q5" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>checkCorrectScobs</code> проверяет корректность строки, содержащей только
                            круглые скобки, и возвращает количество правильно закрытых пар скобок и булево значение,
                            указывающее на общую корректность последовательности.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>isCorrect</code>: флаг корректности последовательности</li>
                                    <li><code>count</code>: счетчик правильно закрытых пар скобок</li>
                                    <li><code>countOpen</code>: счетчик открытых скобок</li>
                                </ul>
                            </li>
                            <li>Итерация по строке:
                                <ul>
                                    <li>Если встречается открывающая скобка '(', увеличиваем <code>countOpen</code></li>
                                    <li>Если встречается закрывающая скобка ')':
                                        <ul>
                                            <li>Проверяем, есть ли открытые скобки (<code>countOpen > 0</code>)</li>
                                            <li>Если нет, возвращаем (0, false)</li>
                                            <li>Если есть, уменьшаем <code>countOpen</code> и увеличиваем
                                                <code>count</code></li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>После итерации:
                                <ul>
                                    <li>Если остались незакрытые скобки (<code>countOpen != 0</code>), устанавливаем
                                        <code>isCorrect = false</code></li>
                                </ul>
                            </li>
                            <li>Возвращаем <code>count</code> и <code>isCorrect</code></li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входной строки</li>
                                    <li>Алгоритм проходит по строке ровно один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти, независимо от размера
                                        входной строки
                                    </li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func checkCorrectScobs(str string) (int, bool) {
	isCorrect := true
	count := 0
	countOpen := 0

	for i := 0; i < len(str); i++ {
		if str[i] == '(' {
			countOpen++
			continue
		}

		if str[i] == ')' {
			if countOpen == 0 {
				return 0, false
			}
			countOpen--
			count++
		}
	}

	if countOpen != 0 {
		isCorrect = false
	}

	return count, isCorrect
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q6">
                        Палиндромы
                    </button>
                </h2>
                <div id="q6" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>isPolindrom</code> проверяет, являются ли две входные строки палиндромами друг
                            друга. То есть, является ли вторая строка обратной первой.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка длины строк:
                                <ul>
                                    <li>Если длины строк не равны, возвращаем <code>false</code></li>
                                </ul>
                            </li>
                            <li>Преобразование строк в слайсы рун:
                                <ul>
                                    <li>Это позволяет корректно работать с Unicode-символами</li>
                                </ul>
                            </li>
                            <li>Итерация по символам:
                                <ul>
                                    <li>Сравниваем символы с начала первой строки с символами с конца второй строки</li>
                                    <li>Если находим несоответствие, возвращаем <code>false</code></li>
                                </ul>
                            </li>
                            <li>Если все символы совпали, возвращаем <code>true</code></li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина строки</li>
                                    <li>Алгоритм проходит по половине символов строки</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>Создаются два новых слайса рун, каждый длиной n</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func isPolindrom(s1, s2 string) bool {
	if len(s1) != len(s2) {
		return false
	}

	s1Rune := []rune(s1)
	s2Rune := []rune(s2)

	for i := 0; i <= len(s1Rune)/2+1; i++ {
		if s1Rune[i] != s2Rune[len(s2Rune)-i-1] {
			return false
		}
	}

	return true
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q7">
                        Проверка строки с пробелами и большими буквами на палиндром
                    </button>
                </h2>
                <div id="q7" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>isPalindrome</code> проверяет, является ли заданная строка палиндромом,
                            игнорируя регистр букв и не учитывая не буквенно-цифровые символы.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация указателей:
                                <ul>
                                    <li>Устанавливаем левый указатель на начало строки, правый - на конец</li>
                                </ul>
                            </li>
                            <li>Итерация по строке:
                                <ul>
                                    <li>Сравниваем символы с левого и правого концов строки</li>
                                    <li>Приводим символы к нижнему регистру</li>
                                    <li>Пропускаем не буквенно-цифровые символы</li>
                                    <li>Если символы не совпадают, возвращаем false</li>
                                    <li>Сдвигаем указатели к центру строки</li>
                                </ul>
                            </li>
                            <li>Проверка завершена:
                                <ul>
                                    <li>Если все символы совпали, возвращаем true</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входной строки</li>
                                    <li>Алгоритм проходит по строке только один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти, независимо от размера
                                        входной строки
                                    </li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func isPalindrome(s string) bool {
	left, right := 0, len(s)-1

	for left < right {
		leftChar := unicode.ToLower(rune(s[left]))
		rightChar := unicode.ToLower(rune(s[right]))

		if !isAlphanumeric(leftChar) {
			left++
			continue
		}
		if !isAlphanumeric(rightChar) {
			right--
			continue
		}

		if leftChar != rightChar {
			return false
		}

		left++
		right--
	}

	return true
}

func isAlphanumeric(r rune) bool {
	return unicode.IsLetter(r) || unicode.IsDigit(r)
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q8">
                        Проверка корректности расстановки скобок
                    </button>
                </h2>
                <div id="q8" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>isValid</code> проверяет, является ли входная строка корректным выражением с
                            правильно расставленными скобками трех типов: круглыми (), квадратными [] и фигурными {}.
                        </p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация:
                                <ul>
                                    <li>Создаем пустой стек для хранения открывающих скобок</li>
                                    <li>Определяем map для сопоставления закрывающих скобок с открывающими</li>
                                </ul>
                            </li>
                            <li>Итерация по строке:
                                <ul>
                                    <li>Если символ - открывающая скобка, добавляем его в стек</li>
                                    <li>Если символ - закрывающая скобка:
                                        <ul>
                                            <li>Проверяем, пуст ли стек или не соответствует ли последняя открывающая
                                                скобка в стеке
                                            </li>
                                            <li>Если условие выполняется, возвращаем false</li>
                                            <li>Иначе удаляем последнюю открывающую скобку из стека</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Проверка завершена:
                                <ul>
                                    <li>Возвращаем true, если стек пуст (все скобки закрыты)</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входной строки</li>
                                    <li>Алгоритм проходит по строке только один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае (когда все символы - открывающие скобки) стек может содержать
                                        все n символов
                                    </li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func isValid(s string) bool {
	stack := make([]rune, 0)
	parentheses := map[rune]rune{')': '(', ']': '[', '}': '{'}

	for _, c := range s {
		if c == '(' || c == '[' || c == '{' {
			stack = append(stack, c)
		} else if len(stack) == 0 || parentheses[c] != stack[len(stack)-1] {
			return false
		} else {
			stack = stack[:len(stack)-1]
		}
	}

	return len(stack) == 0
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q9">
                        Поиск самого длинного палиндрома в строке
                    </button>
                </h2>
                <div id="q9" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>longestPalindrome</code> находит самый длинный палиндром в заданной строке.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка граничных случаев:
                                <ul>
                                    <li>Если длина строки меньше 2, возвращаем саму строку</li>
                                </ul>
                            </li>
                            <li>Итерация по каждому символу строки:
                                <ul>
                                    <li>Для каждого символа проверяем палиндромы с нечетной длиной (центр - текущий
                                        символ)
                                    </li>
                                    <li>Для каждого символа проверяем палиндромы с четной длиной (центр - между текущим
                                        и следующим символом)
                                    </li>
                                    <li>Используем вспомогательную функцию <code>expandAroundCenter</code> для
                                        расширения палиндрома
                                    </li>
                                    <li>Обновляем информацию о самом длинном найденном палиндроме</li>
                                </ul>
                            </li>
                            <li>Возвращаем найденный самый длинный палиндром</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n^2)
                                <ul>
                                    <li>n - длина входной строки</li>
                                    <li>Для каждого символа мы можем расширяться до краев строки</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func longestPalindrome(s string) string {
	if len(s) < 2 {
		return s
	}

	start, maxLength := 0, 1

	for i := 0; i < len(s); i++ {
		// Проверяем палиндромы с нечетной длиной
		len1 := expandAroundCenter(s, i, i)
		// Проверяем палиндромы с четной длиной
		len2 := expandAroundCenter(s, i, i+1)

		length := max(len1, len2)
		if length > maxLength {
			start = i - (length-1)/2
			maxLength = length
		}
	}

	return s[start : start+maxLength]
}

func expandAroundCenter(s string, left, right int) int {
	for left >= 0 && right < len(s) && s[left] == s[right] {
		left--
		right++
	}
	return right - left - 1
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q10">
                        Поиск длины самой длинной подстроки без повторяющихся символов
                    </button>
                </h2>
                <div id="q10" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>lengthOfLongestSubstring</code> находит длину самой длинной подстроки без
                            повторяющихся символов в заданной строке.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка на пустую строку</li>
                            <li>Преобразование строки в массив рун (для корректной работы с Unicode)</li>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>subLengs</code> - длина самой длинной найденной подстроки</li>
                                    <li><code>curSubRunes</code> - карта для хранения последних позиций символов</li>
                                </ul>
                            </li>
                            <li>Использование техники "скользящего окна":
                                <ul>
                                    <li>Проход по строке с двумя указателями: <code>left</code> и <code>right</code>
                                    </li>
                                    <li>Если символ уже встречался в текущем окне, сдвигаем левую границу</li>
                                    <li>Обновление позиции текущего символа в карте</li>
                                    <li>Обновление максимальной длины подстроки, если текущее окно больше</li>
                                </ul>
                            </li>
                            <li>Возврат длины самой длинной подстроки</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - длина входной строки</li>
                                    <li>Алгоритм проходит по строке один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(k)
                                <ul>
                                    <li>k - размер алфавита (максимальное количество уникальных символов)</li>
                                    <li>В худшем случае может быть O(min(n, m)), где m - размер используемого алфавита
                                    </li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func lengthOfLongestSubstring(s string) int {
	if s == "" {
		return 0
	}

	runes := []rune(s)
	left, subLengs := 0, 0
	curSubRunes := make(map[rune]int)

	for right := 0; right < len(runes); right++ {
		// Если текущий символ уже встречался в текущем окне, сдвигаем левую границу окна.
		if idx, ok := curSubRunes[runes[right]]; ok && idx >= left {
			left = idx + 1
		}
		curSubRunes[runes[right]] = right // пишем текущий символ
		// если текущее окно больше предыдущего обновляем
		subLengs = max(subLengs, right-left+1)
	}

	return subLengs
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q11">
                        Проверка включения перестановки
                    </button>
                </h2>
                <div id="q11" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>checkInclusion</code> проверяет, содержит ли строка s2 перестановку строки s1.
                        </p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка начальных условий: если s1 длиннее s2, возвращаем false</li>
                            <li>Инициализация массива count для подсчета частоты символов</li>
                            <li>Обработка первого окна размером len(s1):
                                <ul>
                                    <li>Увеличиваем счетчики для символов s1</li>
                                    <li>Уменьшаем счетчики для соответствующих символов s2</li>
                                </ul>
                            </li>
                            <li>Проверка, все ли счетчики равны нулю (перестановка найдена)</li>
                            <li>Скользящее окно по оставшейся части s2:
                                <ul>
                                    <li>Удаляем символ, выходящий из окна</li>
                                    <li>Добавляем новый символ в окно</li>
                                    <li>Проверяем, все ли счетчики равны нулю</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - длина строки s2</li>
                                    <li>Один проход по s2 с константными операциями на каждом шаге</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется фиксированный массив count размером 26 (для букв английского
                                        алфавита)
                                    </li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func checkInclusion(s1 string, s2 string) bool {
	if len(s1) > len(s2) {
		return false
	}

	count := [26]int{}
	for i := range s1 {
		count[s1[i]-'a']++
		count[s2[i]-'a']--
	}

	if allZero(count) {
		return true
	}

	for i := len(s1); i < len(s2); i++ {
		count[s2[i]-'a']--
		count[s2[i-len(s1)]-'a']++
		if allZero(count) {
			return true
		}
	}

	return false
}

func allZero(count [26]int) bool {
	for _, v := range count {
		if v != 0 {
			return false
		}
	}
	return true
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q12">
                        Упрощение пути в файловой системе
                    </button>
                </h2>
                <div id="q12" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>simplifyPath</code> преобразует абсолютный путь в файловой системе в
                            канонический путь, удаляя избыточные элементы и нормализуя структуру.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Разделение входного пути на компоненты с помощью <code>strings.Split</code></li>
                            <li>Инициализация стека для хранения валидных компонентов пути</li>
                            <li>Итерация по компонентам пути:
                                <ul>
                                    <li>Игнорирование пустых компонентов и "." (текущая директория)</li>
                                    <li>Обработка ".." (переход на уровень выше) путем удаления последнего элемента из
                                        стека
                                    </li>
                                    <li>Добавление валидных компонентов в стек</li>
                                </ul>
                            </li>
                            <li>Сборка результирующего пути из элементов стека</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - количество компонентов в пути</li>
                                    <li>Один проход по всем компонентам пути</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(n)
                                <ul>
                                    <li>В худшем случае стек может содержать все компоненты пути</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func simplifyPath(path string) string {
    // Разделяем путь на компоненты
    components := strings.Split(path, "/")
    stack := []string{}

    for _, component := range components {
        switch component {
        case "", ".":
            // Игнорируем пустые компоненты и текущую директорию
            continue
        case "..":
            // Переходим на уровень выше, если это возможно
            if len(stack) > 0 {
                stack = stack[:len(stack)-1]
            }
        default:
            // Добавляем валидный компонент пути
            stack = append(stack, component)
        }
    }

    // Собираем упрощенный путь
    result := "/" + strings.Join(stack, "/")
    return result
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q13">
                        Сжатие строки (байт)
                    </button>
                </h2>
                <div id="q13" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Функция <code>compress</code> выполняет сжатие строки, заменяя последовательности
                            повторяющихся символов на символ и количество его повторений. Сжатие выполняется "на месте",
                            модифицируя входной массив байтов.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка на короткие входные данные (длина 0 или 1)</li>
                            <li>Инициализация индекса записи и счетчика повторений</li>
                            <li>Итерация по символам строки:
                                <ul>
                                    <li>Подсчет последовательных повторений символа</li>
                                    <li>При смене символа или достижении конца строки:
                                        <ul>
                                            <li>Запись символа</li>
                                            <li>Запись количества повторений (если больше 1)</li>
                                            <li>Обновление индекса записи</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Возврат новой длины сжатой строки</li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>n - длина входной строки</li>
                                    <li>Один проход по всем символам</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Модификация выполняется "на месте"</li>
                                    <li>Используется фиксированное количество дополнительных переменных</li>
                                </ul>
                            </li>
                        </ul>

                        <pre><code class="go">func compress(chars []byte) int {
    if len(chars) <= 1 {
        return len(chars)
    }

    writeIndex := 0
    count := 1

    for i := 1; i <= len(chars); i++ {
        if i < len(chars) && chars[i] == chars[i-1] {
            count++
        } else {
            chars[writeIndex] = chars[i-1]
            writeIndex++

            if count > 1 {
                countStr := strconv.Itoa(count)
                for _, digit := range countStr {
                    chars[writeIndex] = byte(digit)
                    writeIndex++
                }
            }
            count = 1
        }
    }

    return writeIndex
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>
</body>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
</html>