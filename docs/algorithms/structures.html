<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><!DOCTYPE html>
        <html lang="ru">
        <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Архитектура</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
<div class="container">
    <header>
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">DevInterview</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="nav-link" href="../php.html">PHP - вопросы</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../php_tasks.html">PHP - задачи</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../go.html">Go - вопросы</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../go_tasks.html">Go - задачи</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../db.html">Базы данных</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../architecture.html">Архитектура</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="../algorithms.html">Алгоритмы</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <main>
        <h1>Алгоритмы - Связанные списки | Деревья</h1>
        <div class="accordion" id="accordionBlock">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q1">
                        Проверка палиндрома
                    </button>
                </h2>
                <div id="q1" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>isPalindrome</code>, которая проверяет, является ли
                            связанный список палиндромом (читается одинаково слева направо и справа налево).</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Проверка базовых случаев:
                                <ul>
                                    <li>Если список пустой или содержит только один элемент, возвращаем true</li>
                                </ul>
                            </li>
                            <li>Нахождение середины списка:
                                <ul>
                                    <li>Используется техника "быстрого и медленного" указателей</li>
                                </ul>
                            </li>
                            <li>Разворот второй половины списка:
                                <ul>
                                    <li>Используется вспомогательная функция <code>reverseList</code></li>
                                </ul>
                            </li>
                            <li>Сравнение первой и развернутой второй половины:
                                <ul>
                                    <li>Проходим по обеим половинам, сравнивая значения узлов</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - количество узлов в списке</li>
                                    <li>Алгоритм проходит по списку дважды: один раз для нахождения середины и
                                        разворота, второй раз для сравнения
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти, независимо от размера
                                        входного списка
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">type ListNode struct {
	Val  int
	Next *ListNode
}

func isPalindrome(head *ListNode) bool {
	if head == nil || head.Next == nil {
		return true
	}

	// Находим середину списка
	slow, fast := head, head
	for fast.Next != nil && fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}

	// Разворачиваем вторую половину списка
	secondHalf := reverseList(slow.Next)

	// Сравниваем первую и вторую половины
	firstHalf := head
	for secondHalf != nil {
		if firstHalf.Val != secondHalf.Val {
			return false
		}
		firstHalf = firstHalf.Next
		secondHalf = secondHalf.Next
	}

	return true
}

// reverseList разворачивает связанный список
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode
	current := head
	for current != nil {
		nextTemp := current.Next
		current.Next = prev
		prev = current
		current = nextTemp
	}
	return prev
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q2">
                        Проверка симметричности бинарного дерева
                    </button>
                </h2>
                <div id="q2" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Код реализует функцию <code>isSymmetric</code>, которая проверяет, является ли заданное
                            бинарное дерево симметричным. Дерево считается симметричным, если левое и правое поддеревья
                            являются зеркальными отражениями друг друга.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Определение структуры узла дерева:
                                <ul>
                                    <li>Структура <code>TreeNode</code> содержит значение узла и указатели на левого и
                                        правого потомков
                                    </li>
                                </ul>
                            </li>
                            <li>Функция <code>isSymmetric</code>:
                                <ul>
                                    <li>Проверяет корневой узел на nil</li>
                                    <li>Вызывает вспомогательную функцию <code>isMirror</code> для левого и правого
                                        поддеревьев
                                    </li>
                                </ul>
                            </li>
                            <li>Функция <code>isMirror</code>:
                                <ul>
                                    <li>Рекурсивно сравнивает левое и правое поддеревья</li>
                                    <li>Проверяет три условия:
                                        <ol>
                                            <li>Оба узла nil (симметричны)</li>
                                            <li>Только один узел nil (не симметричны)</li>
                                            <li>Значения узлов равны и их поддеревья симметричны</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - количество узлов в дереве</li>
                                    <li>Каждый узел посещается ровно один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(h)
                                <ul>
                                    <li>Где h - высота дерева</li>
                                    <li>В худшем случае (несбалансированное дерево) может достигать O(n)</li>
                                    <li>Обусловлена рекурсивными вызовами на стеке</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

// isSymmetric проверяет, является ли бинарное дерево симметричным
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}
	return isMirror(root.Left, root.Right)
}

// isMirror рекурсивно проверяет, являются ли два поддерева зеркальными отражениями друг друга
func isMirror(left, right *TreeNode) bool {
	// Если оба узла nil, они симметричны
	if left == nil && right == nil {
		return true
	}
	// Если только один из узлов nil, они не симметричны
	if left == nil || right == nil {
		return false
	}
	// Проверяем, равны ли значения узлов и симметричны ли их поддеревья
	return (left.Val == right.Val) &&
		isMirror(left.Left, right.Right) &&
		isMirror(left.Right, right.Left)
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q3">
                        Слияние двух отсортированных массивов
                    </button>
                </h2>
                <div id="q3" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>merge</code>, которая объединяет два отсортированных массива
                            <code>nums1</code> и <code>nums2</code> в один отсортированный массив. Результат сохраняется
                            в массиве <code>nums1</code>, который изначально имеет достаточно места для хранения всех
                            элементов.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация указателей:
                                <ul>
                                    <li><code>p1</code>: указывает на последний элемент в <code>nums1</code></li>
                                    <li><code>p2</code>: указывает на последний элемент в <code>nums2</code></li>
                                    <li><code>p</code>: указывает на последнюю позицию в объединенном массиве</li>
                                </ul>
                            </li>
                            <li>Итерация с конца массивов:
                                <ul>
                                    <li>Сравниваем элементы <code>nums1[p1]</code> и <code>nums2[p2]</code></li>
                                    <li>Больший элемент помещаем в позицию <code>p</code> массива <code>nums1</code>
                                    </li>
                                    <li>Сдвигаем соответствующий указатель и <code>p</code></li>
                                </ul>
                            </li>
                            <li>Продолжаем, пока не обработаем все элементы из <code>nums2</code></li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(m+n)
                                <ul>
                                    <li>m - количество элементов в nums1</li>
                                    <li>n - количество элементов в nums2</li>
                                    <li>Алгоритм проходит по всем элементам обоих массивов один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Алгоритм работает in-place, не используя дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int) {
	// Указатели на последние элементы массивов
	p1 := m - 1    // для nums1
	p2 := n - 1    // для nums2
	p := m + n - 1 // для объединенного массива

	// Идем с конца массивов, заполняя nums1 с конца
	for p2 >= 0 {
		if p1 >= 0 && nums1[p1] > nums2[p2] {
			nums1[p] = nums1[p1]
			p1--
		} else {
			nums1[p] = nums2[p2]
			p2--
		}
		p--
	}
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q4">
                        Поиск пропущенного числа
                    </button>
                </h2>
                <div id="q4" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>missingNumber</code>, которая находит пропущенное число в
                            последовательности от 0 до n, где n - длина входного массива <code>nums</code>.
                            Предполагается, что в массиве <code>nums</code> содержатся все числа от 0 до n, кроме
                            одного.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация переменных:
                                <ul>
                                    <li><code>sum</code>: сумма всех чисел от 0 до n (включительно)</li>
                                    <li><code>res</code>: сумма всех чисел в массиве <code>nums</code></li>
                                </ul>
                            </li>
                            <li>Итерация по массиву:
                                <ul>
                                    <li>Добавляем i к <code>sum</code> (учитывая числа от 0 до n-1)</li>
                                    <li>Добавляем <code>nums[i]</code> к <code>res</code></li>
                                </ul>
                            </li>
                            <li>Вычисление пропущенного числа:
                                <ul>
                                    <li>Возвращаем разницу между <code>sum</code> и <code>res</code></li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входного массива</li>
                                    <li>Алгоритм проходит по массиву один раз</li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Используется постоянное количество дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func missingNumber(nums []int) int {
	sum := len(nums)
	res := 0
	for i := 0; i < len(nums); i++ {
		sum += i
		res += nums[i]
	}

	return sum - res
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#q5">
                        Перемещение нулей в конец массива
                    </button>
                </h2>
                <div id="q5" class="accordion-collapse collapse" data-bs-parent="#accordionBlock">
                    <div class="accordion-body">
                        <p>Этот код реализует функцию <code>moveZeroes</code>, которая перемещает все нули в конец
                            массива <code>nums</code>, сохраняя относительный порядок ненулевых элементов.</p>
                        <h3>Алгоритм решения</h3>
                        <ol>
                            <li>Инициализация указателя <code>nonZeroIndex</code>:
                                <ul>
                                    <li>Указывает на позицию, куда нужно поместить следующий ненулевой элемент</li>
                                </ul>
                            </li>
                            <li>Первый проход по массиву:
                                <ul>
                                    <li>Если элемент не равен нулю, перемещаем его на позицию <code>nonZeroIndex</code>
                                    </li>
                                    <li>Увеличиваем <code>nonZeroIndex</code></li>
                                </ul>
                            </li>
                            <li>Второй проход по оставшейся части массива:
                                <ul>
                                    <li>Заполняем все позиции от <code>nonZeroIndex</code> до конца массива нулями</li>
                                </ul>
                            </li>
                        </ol>
                        <ul>
                            <li><strong>Временная сложность:</strong> O(n)
                                <ul>
                                    <li>Где n - длина входного массива</li>
                                    <li>Алгоритм проходит по массиву дважды: один раз для перемещения ненулевых
                                        элементов и второй раз для заполнения нулями
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Пространственная сложность:</strong> O(1)
                                <ul>
                                    <li>Алгоритм работает in-place, не используя дополнительной памяти</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="go">func moveZeroes(nums []int) {
	nonZeroIndex := 0

	// Перемещаем все ненулевые элементы в начало массива
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			nums[nonZeroIndex] = nums[i]
			nonZeroIndex++
		}
	}

	// Заполняем оставшуюся часть массива нулями
	for i := nonZeroIndex; i < len(nums); i++ {
		nums[i] = 0
	}
}</code>
                                        </pre>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>
</body>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
</html></title>
</head>
<body>

</body>
</html>